{"title":"花指令去除wp","slug":"花指令去除wp","date":"2018-12-05T13:50:11.000Z","updated":"2018-12-06T06:48:32.000Z","comments":true,"path":"api/articles/花指令去除wp.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p>​    这学期《恶意代码分析》这门课的作业留了一道RE题，其中包含大量批量插入的花指令。在这里简单记录一下分析过程。</p>\n<h2 id=\"0x00-基本分析\"><a href=\"#0x00-基本分析\" class=\"headerlink\" title=\"0x00  基本分析\"></a>0x00  基本分析</h2><p>首先动态执行程序看一下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\UCAS\\malware_analyse&gt;Anti.exe</span><br><span class=\"line\">The encypted flag in hex is:</span><br><span class=\"line\">3A3B3138233B3C3437300B3730073228393523062E2B242A</span><br><span class=\"line\">Please input cipher character:3</span><br><span class=\"line\">Hex result for encrypt string 'thisisasimplesamplestring' is:</span><br><span class=\"line\">7A6D6B7E63756C706D61766661796B62756067787271656B6B</span><br></pre></td></tr></table></figure>\n<p>输入点只有一个，要求输入一个加密字符，然后就会输出对<code>thisisasimplesamplestring</code>字符串的加密结果。那么显然，只要我们能够分析并逆向出加密算法，就能把加密后的flag解密得到原flag，当然这个加密算法应该是可逆的，否则就有点难办了。</p>\n<p>首先用IDA加载Anti.exe，并加载题目所给的pdb文件——应该说出题人还是很好的（谢谢师兄~_~）。之后粗略浏览反汇编代码，主要有两点发现：</p>\n<ul>\n<li>该程序应该由C++语言编写，因为有虚表和类层次关系</li>\n<li>代码中添加了大量花指令</li>\n</ul>\n<h2 id=\"0x01-花指令分析\"><a href=\"#0x01-花指令分析\" class=\"headerlink\" title=\"0x01  花指令分析\"></a>0x01  花指令分析</h2><p>下面对代码中涉及到的花指令作基本分析</p>\n<p>1.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401A1B loc_401A1B:                             ; CODE XREF: .text:loc_401A1B↑j</span><br><span class=\"line\">.text:00401A1B                 jmp     short near ptr loc_401A1B+1</span><br><span class=\"line\">.text:00401A1D ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:00401A1D                 ror     byte ptr [eax-73h], 45h</span><br></pre></td></tr></table></figure>\n<p>这是因为两条顺序执行的指令使用了一个公共byte，而IDA在反汇编完一条指令后，会从这条指令的下一个地址处开始反汇编，所以无法表示这种情况。具体来说，0x401a1b处是<code>0xeb</code>,0x401a1c处是<code>0xff</code>，IDA首先把0xeb翻译成jmp指令，然后往下找操作数，是短跳转+1；之后，就会顺序反汇编0x401a1d处的内容。但是程序在执行时实际上跳转到0x1a1c处执行，这就导致一个矛盾。</p>\n<p>手工去掉花指令还原即可，暂时不用管那个垃圾字节，在脚本批量去除阶段可以Patch为NOP指令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401A14 ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:00401A1B                 db 0EBh</span><br><span class=\"line\">.text:00401A1C ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:00401A1C                 inc     eax</span><br><span class=\"line\">.text:00401A1E                 dec     eax</span><br><span class=\"line\">.text:00401A1F                 lea     eax, [ebp-34h]</span><br></pre></td></tr></table></figure>\n<p>2.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:004019E5                 push    offset __ehhandler$?enc2@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@D@Z</span><br><span class=\"line\">.text:004019EA                 mov     eax, large fs:0</span><br><span class=\"line\">.text:004019F0                 push    eax</span><br><span class=\"line\">.text:004019F1                 mov     large fs:0, esp</span><br><span class=\"line\">......</span><br><span class=\"line\">.text:00401A4E                 xor     eax, eax</span><br><span class=\"line\">.text:00401A50                 idiv    eax</span><br><span class=\"line\">.text:00401A52                 retn</span><br><span class=\"line\">.text:00401A53                 db 8Bh</span><br><span class=\"line\">.text:00401A54                 dd 64082464h, 0A1h, 8B008B00h, 0A36400h, 83000000h, 5D5808C4h</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n<p>这算是第二种花指令。0x4019e5处的四条指令首先将fs[0]压入堆栈，从而使得执行完成后，fs[0]指向栈顶。之后，构造一个err结构。在0x401a4e处，故意触发一个除零异常，然后就会进入异常处理流程。</p>\n<p>同时，由于除零后是一条retn指令，IDA在反汇编时不会将retn的下一个地址识别为指令，直到找到一个函数头<code>push    ebp; mov    ebp, esp</code> ，这又使得反汇编出错。</p>\n<p>详细的异常处理流程我们在静态分析阶段不好分析，如读者感兴趣可以详细查阅资料。但我们通过OD调试可以大体了解程序的控制流。</p>\n<p>在0x401a50处下断，并在调试选项中去掉所有忽略异常的勾选，点击确定后F9断到断点处，然后F8单步调试，到达如下位置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7C92E460    8B1C24          mov ebx,dword ptr ss:[esp]</span><br><span class=\"line\">7C92E463    51              push ecx</span><br><span class=\"line\">7C92E464    53              push ebx</span><br><span class=\"line\">7C92E465    E8 E6C40100     call ntdll.7C94A950</span><br></pre></td></tr></table></figure>\n<p>F7步入函数调用，然后继续单步跟，看到一个可疑位置，会将0x401a53的地址作为参数压栈，然后调用一个函数，步入函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7C923261    FF7424 20       push dword ptr ss:[esp+0x20]             ; Anti.00401A53</span><br><span class=\"line\">7C923265    FF7424 20       push dword ptr ss:[esp+0x20]             ; Anti.00401A53</span><br><span class=\"line\">7C923269    FF7424 20       push dword ptr ss:[esp+0x20]             ; Anti.00401A53</span><br><span class=\"line\">7C92326D    FF7424 20       push dword ptr ss:[esp+0x20]             ; Anti.00401A53</span><br><span class=\"line\">7C923271    FF7424 20       push dword ptr ss:[esp+0x20]             ; Anti.00401A53</span><br><span class=\"line\">7C923275    E8 08000000     call ntdll.7C923282</span><br></pre></td></tr></table></figure>\n<p>果然，此处最终<code>call ecx</code>，使得eip跳转到0x401a53处执行。所以我们应该在0x401a53处按C识别为代码，修复反汇编。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7C923289    64:FF35 0000000&gt;push dword ptr fs:[0]</span><br><span class=\"line\">7C923290    64:8925 0000000&gt;mov dword ptr fs:[0],esp</span><br><span class=\"line\">7C923297    FF75 14         push dword ptr ss:[ebp+0x14]</span><br><span class=\"line\">7C92329A    FF75 10         push dword ptr ss:[ebp+0x10]</span><br><span class=\"line\">7C92329D    FF75 0C         push dword ptr ss:[ebp+0xC]</span><br><span class=\"line\">7C9232A0    FF75 08         push dword ptr ss:[ebp+0x8]</span><br><span class=\"line\">7C9232A3    8B4D 18         mov ecx,dword ptr ss:[ebp+0x18]          ; Anti.00401A53</span><br><span class=\"line\">7C9232A6    FFD1            call ecx                                 ; Anti.00401A53</span><br></pre></td></tr></table></figure>\n<p>3.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401A8A                 jz      near ptr loc_401A96+4</span><br><span class=\"line\">.text:00401A90                 jnz     near ptr loc_401A96+4</span><br><span class=\"line\">.text:00401A96</span><br><span class=\"line\">.text:00401A96 loc_401A96:                             ; CODE XREF: .text:00401A8A↑j</span><br><span class=\"line\">.text:00401A96                                         ; .text:00401A90↑j</span><br><span class=\"line\">.text:00401A96                 call    near ptr 0F733CACh</span><br></pre></td></tr></table></figure>\n<p>比起上面两种花指令，这一种都算小菜啦。构造连续两个互补的条件跳转到同一位置。因为条件跳转为基本块出口，诱导IDA反汇编基本块邻接地址为新的基本块入口。实际上只是几个字节的垃圾数据。简单修复即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401A8A                 jz      loc_401A9A</span><br><span class=\"line\">.text:00401A90                 jnz     loc_401A9A</span><br><span class=\"line\">.text:00401A90 ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:00401A96                 db 0E8h</span><br><span class=\"line\">.text:00401A97                 db  11h</span><br><span class=\"line\">.text:00401A98                 db  22h ; &quot;</span><br><span class=\"line\">.text:00401A99                 db  33h ; 3</span><br><span class=\"line\">.text:00401A9A ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:00401A9A</span><br><span class=\"line\">.text:00401A9A loc_401A9A:                             ; CODE XREF: .text:00401A8A↑j</span><br><span class=\"line\">.text:00401A9A                                         ; .text:00401A90↑j</span><br></pre></td></tr></table></figure>\n<p>4.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401ACA                 xor     eax, eax</span><br><span class=\"line\">.text:00401ACC                 jz      near ptr loc_401AD2+1</span><br><span class=\"line\">.text:00401AD2</span><br><span class=\"line\">.text:00401AD2 loc_401AD2:                             ; CODE XREF: .text:00401ACC↑j</span><br><span class=\"line\">.text:00401AD2                 call    near ptr 0D085A62Fh</span><br></pre></td></tr></table></figure>\n<p>这种是构造一个恒真的条件跳转，再加上一个垃圾字节，很好理解。简单修复即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401ACA                 xor     eax, eax</span><br><span class=\"line\">.text:00401ACC                 jz      loc_401AD3</span><br><span class=\"line\">.text:00401ACC ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:00401AD2                 db 0E8h</span><br><span class=\"line\">.text:00401AD3 ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:00401AD3</span><br><span class=\"line\">.text:00401AD3 loc_401AD3:                             ; CODE XREF: .text:00401ACC↑j</span><br><span class=\"line\">.text:00401AD3                 pop     eax</span><br><span class=\"line\">.text:00401AD4                 mov     eax, [ebp-30h]</span><br></pre></td></tr></table></figure>\n<p>分析到这里，第一个函数enc1的花指令我们已经完全去除了，在IDA中按F5可以进行反编译。不过在手动分析下一个函数后，按F5无法进行反编译。这是因为IDA没有将其识别为函数，我们在已修复的函数入口点处按P MakeProc即可。</p>\n<h2 id=\"0x02-脚本批量去除花指令\"><a href=\"#0x02-脚本批量去除花指令\" class=\"headerlink\" title=\"0x02 脚本批量去除花指令\"></a>0x02 脚本批量去除花指令</h2><p>到这里相信手工去除花指令已经难不倒大家了，但是程序中显然有大量批量插入的花指令，如果一一通过手工去除，不太可行。这时候，我们可以借助IDAPython这个工具编写一个去除花指令的插件。<a href=\"https://www.hex-rays.com/products/ida/support/idapython_docs/\" target=\"_blank\" rel=\"noopener\">官方文档</a>对于IDAPython的API有一定程度的讲解，但是这个东西还是有一定的学习成本的，如果感觉上手困难可以看一下Hex-Rays官方每年举办的IDA插件大赛的获奖作品（<a href=\"https://hex-rays.com/contests/\" target=\"_blank\" rel=\"noopener\">链接在这</a>），学习一下。</p>\n<p>这里先直接给出脚本。其实写的很不好，主要思路就是逐指令或逐字节遍历，然后对这几种花指令予以识别和去除。同时由于比较懒，直接设置remove函数执行5次，暴力解决递归问题。不过多执行几次是没有副作用的。</p>\n<p>另外，执行脚本后，可能还会有极少量代码反汇编出错，在分析到相应函数后手工按C识别为代码即可。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> ida_auto <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> ida_bytes <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> ida_ua <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">change = <span class=\"number\">0</span></span><br><span class=\"line\">startea = <span class=\"number\">0x4019e0</span></span><br><span class=\"line\">endea = <span class=\"number\">0x405230</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">preprocess</span><span class=\"params\">(curea = startea)</span>:</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> curea &lt;= endea:</span><br><span class=\"line\">\t\tauto_make_code(curea)</span><br><span class=\"line\">\t\tcurea = next_head(curea, endea)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">remove</span><span class=\"params\">(curea = startea)</span>:</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> curea &lt;= endea:</span><br><span class=\"line\">\t\t<span class=\"comment\"># print hex(curea)</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> GetDisasm(curea) == <span class=\"string\">\"retn\"</span>:</span><br><span class=\"line\">\t\t\tMakeCode(curea + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> GetDisasm(curea).startswith(<span class=\"string\">\"db\"</span>) <span class=\"keyword\">is</span> <span class=\"literal\">True</span> <span class=\"keyword\">and</span> GetDisasm(curea + <span class=\"number\">1</span>).startswith(<span class=\"string\">\"db\"</span>) <span class=\"keyword\">is</span> <span class=\"literal\">False</span> <span class=\"keyword\">and</span> GetDisasm(curea).endswith(<span class=\"string\">\")\"</span>) <span class=\"keyword\">is</span> <span class=\"literal\">False</span>:</span><br><span class=\"line\">\t\t\tdo_unknown(curea + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\tMakeCode(curea)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> xref <span class=\"keyword\">in</span> XrefsFrom(curea, <span class=\"number\">1</span>):</span><br><span class=\"line\">\t\t\t<span class=\"comment\"># print hex(xref.frm), hex(xref.to)</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> xref.to - xref.frm == <span class=\"number\">1</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> get_byte(xref.frm) == <span class=\"number\">0xeb</span>:</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\"># print \"yes\"</span></span><br><span class=\"line\">\t\t\t\t\tea = xref.frm</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">20</span>):</span><br><span class=\"line\">\t\t\t\t\t\tdo_unknown(ea)</span><br><span class=\"line\">\t\t\t\t\t\tea += <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t\t\tea = xref.to</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">20</span>):</span><br><span class=\"line\">\t\t\t\t\t\tMakeCode(ea)</span><br><span class=\"line\">\t\t\t\t\t\tea += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\tpatch_byte(xref.frm, <span class=\"number\">0x90</span>)</span><br><span class=\"line\">\t\t\t\t\tchange = MakeCode(xref.frm)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">elif</span> xref.to == next_head(curea, endea) + <span class=\"number\">1</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> get_byte(xref.to - <span class=\"number\">1</span>) == <span class=\"number\">0xe8</span>:</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\"># print \"yess\"</span></span><br><span class=\"line\">\t\t\t\t\tdo_unknown(xref.to - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t\tea = xref.to</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">20</span>):</span><br><span class=\"line\">\t\t\t\t\t\tMakeCode(ea)</span><br><span class=\"line\">\t\t\t\t\t\tea += <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t\t\tpatch_byte(xref.to - <span class=\"number\">1</span>, <span class=\"number\">0x90</span>)</span><br><span class=\"line\">\t\t\t\t\tMakeCode(xref.to - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">elif</span> xref.to == next_head(next_head(curea, endea), endea) + <span class=\"number\">4</span>:</span><br><span class=\"line\">\t\t\t\ttar_ea = next_head(next_head(curea, endea), endea)</span><br><span class=\"line\">\t\t\t\tea = tar_ea</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">20</span>):</span><br><span class=\"line\">\t\t\t\t\tdo_unknown(ea)</span><br><span class=\"line\">\t\t\t\t\tea += <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t\tea = xref.to</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">20</span>):</span><br><span class=\"line\">\t\t\t\t\tMakeCode(ea)</span><br><span class=\"line\">\t\t\t\t\tea += <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t\tea = tar_ea</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>):</span><br><span class=\"line\">\t\t\t\t\tpatch_byte(ea, <span class=\"number\">0x90</span>)</span><br><span class=\"line\">\t\t\t\t\tea += <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t\tea = tar_ea</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>):</span><br><span class=\"line\">\t\t\t\t\tMakeCode(ea)</span><br><span class=\"line\">\t\t\t\t\tea += <span class=\"number\">1</span></span><br><span class=\"line\">\t\tcurea = next_head(curea, endea)</span><br><span class=\"line\">\tAnalyseRange(startea,endea)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">recognize</span><span class=\"params\">(curea = startea)</span>:</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> curea &lt;= endea:</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> GetDisasm(curea) == <span class=\"string\">\"push    ebp\"</span> <span class=\"keyword\">and</span> GetDisasm(curea+<span class=\"number\">1</span>) == <span class=\"string\">\"mov     ebp, esp\"</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">print</span> <span class=\"string\">\"should be make\"</span></span><br><span class=\"line\">\t\t\tauto_make_proc(curea)</span><br><span class=\"line\">\t\tcurea = next_head(curea, endea)</span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">\tpreprocess()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>):</span><br><span class=\"line\">\t\tremove()</span><br><span class=\"line\">\trecognize()</span><br></pre></td></tr></table></figure>\n<h2 id=\"0x03-加密算法分析与逆向\"><a href=\"#0x03-加密算法分析与逆向\" class=\"headerlink\" title=\"0x03  加密算法分析与逆向\"></a>0x03  加密算法分析与逆向</h2><p>至此，我们已经解决了花指令问题，可以开始分析具体算法了。main函数中会调用encrypt函数加密，最后调用hexencode函数输出结果。</p>\n<p>直接查看encrypt函数的F5代码，但是由于是C++程序，伪C代码比较乱，看不出所以然。不过我们可以明确encrypt函数中首先调用了enc2函数。其核心代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401ABF                 call    j_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::length(void)</span><br><span class=\"line\">.text:00401AC4                 cmp     [ebp-30h], eax  ; cnt &lt; 源字符串长度时</span><br><span class=\"line\">.text:00401AC7                 jnb     short loc_401B18</span><br><span class=\"line\">.text:00401AC9                 push    eax             ; 先push eax</span><br><span class=\"line\">.text:00401ACA                 xor     eax, eax        ; 花指令</span><br><span class=\"line\">.text:00401ACC                 jz      loc_401AD3      ; pop eax，恢复</span><br><span class=\"line\">.text:00401AD2                 nop</span><br><span class=\"line\">.text:00401AD3</span><br><span class=\"line\">.text:00401AD3 loc_401AD3:                             ; CODE XREF: .text:00401ACC↑j</span><br><span class=\"line\">.text:00401AD3                 pop     eax             ; pop eax，恢复</span><br><span class=\"line\">.text:00401AD4                 mov     eax, [ebp-30h]  ; eax = cnt</span><br><span class=\"line\">.text:00401AD7                 push    eax</span><br><span class=\"line\">.text:00401AD8                 lea     ecx, [ebp+0Ch]</span><br><span class=\"line\">.text:00401ADB                 call    j_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; 取源字符串中下标cnt处字符</span><br><span class=\"line\">.text:00401AE0                 movsx   ebx, byte ptr [eax] ; 放到ebx中</span><br><span class=\"line\">.text:00401AE3                 lea     ecx, [ebp-1Ch]</span><br><span class=\"line\">.text:00401AE6                 call    j_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::length(void)</span><br><span class=\"line\">.text:00401AEB                 mov     ecx, eax        ; 取字符串&quot;2&quot;的长度放到ecx中</span><br><span class=\"line\">.text:00401AED                 mov     eax, [ebp-30h]  ; eax = cnt</span><br><span class=\"line\">.text:00401AF0                 xor     edx, edx        ; 高位置0</span><br><span class=\"line\">.text:00401AF2                 div     ecx             ; cnt / &quot;2&quot;的长度</span><br><span class=\"line\">.text:00401AF4                 push    edx             ; 余数压栈</span><br><span class=\"line\">.text:00401AF5                 lea     ecx, [ebp-1Ch]</span><br><span class=\"line\">.text:00401AF8                 call    j_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; 取key[cnt%len(cip)]</span><br><span class=\"line\">.text:00401AFD                 movsx   edx, byte ptr [eax] ; 放在edx中</span><br><span class=\"line\">.text:00401B00                 xor     ebx, edx        ; ord[cnt] ^ key[cnt%len(cip)]</span><br><span class=\"line\">.text:00401B02                 movsx   eax, byte ptr [ebp+1Ch]</span><br><span class=\"line\">.text:00401B06                 xor     ebx, eax\t\t   ; 再次与输入的密钥字符异或</span><br><span class=\"line\">.text:00401B08                 mov     ecx, [ebp-30h]</span><br><span class=\"line\">.text:00401B0B                 push    ecx</span><br><span class=\"line\">.text:00401B0C                 lea     ecx, [ebp-2Ch]</span><br><span class=\"line\">.text:00401B0F                 call    j_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](uint)</span><br><span class=\"line\">.text:00401B14                 mov     [eax], bl</span><br></pre></td></tr></table></figure>\n<p>这里0x401aeb处的操作比较有趣，这个字符串为什么是2呢？猜想到可能与函数名enc2的2有关，于是用OD调试enc3、enc5函数，发现这个串变成”3”和”5”，这说明果然与函数名有关。</p>\n<p>调用enc2并在两次按位异或后，将结果存储并回到encrpyt函数体调用enc3，然后通过异常处理链调用enc5、enc8……，最后调用enc28657，最后得到加密结果。因此，加密算法的逻辑已经很清楚了，给出Python实现</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">encrypt</span><span class=\"params\">(key)</span>:</span></span><br><span class=\"line\">\tres = <span class=\"string\">\"thisisasimplesamplestring\"</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">13</span>,<span class=\"number\">21</span>,<span class=\"number\">34</span>,<span class=\"number\">55</span>,<span class=\"number\">89</span>,<span class=\"number\">144</span>,<span class=\"number\">233</span>,<span class=\"number\">377</span>,<span class=\"number\">610</span>,<span class=\"number\">987</span>,<span class=\"number\">1597</span>,<span class=\"number\">2584</span>,<span class=\"number\">4181</span>,<span class=\"number\">6765</span>,<span class=\"number\">10946</span>,<span class=\"number\">17711</span>,<span class=\"number\">28657</span>]:</span><br><span class=\"line\">\t\tnum = list(str(n))</span><br><span class=\"line\">\t\ttmp = <span class=\"string\">\"\"</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i,b <span class=\"keyword\">in</span> enumerate(res):</span><br><span class=\"line\">\t\t\ttmp += chr((((ord(b) ^ ord(num[i % len(num)]) &amp; <span class=\"number\">0xff</span>) ^ key) &amp; <span class=\"number\">0xff</span>))</span><br><span class=\"line\">\t\tres = tmp</span><br><span class=\"line\">\tflag = res</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> flag</span><br></pre></td></tr></table></figure>\n<p>为了求解flag，需要求解这个算法的逆算法。因为都是按位异或，很容易得到逆算法，并爆破所有可见字符即可catch flag。</p>\n<p>最终脚本如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decrypt</span><span class=\"params\">(key)</span>:</span></span><br><span class=\"line\">\tencrypted = <span class=\"string\">\"\\x3A\\x3B\\x31\\x38\\x23\\x3B\\x3C\\x34\\x37\\x30\\x0B\\x37\\x30\\x07\\x32\\x28\\x39\\x35\\x23\\x06\\x2E\\x2B\\x24\\x2A\"</span>[::<span class=\"number\">-1</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">13</span>,<span class=\"number\">21</span>,<span class=\"number\">34</span>,<span class=\"number\">55</span>,<span class=\"number\">89</span>,<span class=\"number\">144</span>,<span class=\"number\">233</span>,<span class=\"number\">377</span>,<span class=\"number\">610</span>,<span class=\"number\">987</span>,<span class=\"number\">1597</span>,<span class=\"number\">2584</span>,<span class=\"number\">4181</span>,<span class=\"number\">6765</span>,<span class=\"number\">10946</span>,<span class=\"number\">17711</span>,<span class=\"number\">28657</span>][::<span class=\"number\">-1</span>]:</span><br><span class=\"line\">\t\t<span class=\"comment\"># print n</span></span><br><span class=\"line\">\t\tnum = list(str(n))</span><br><span class=\"line\">\t\ttmp = <span class=\"string\">\"\"</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i,b <span class=\"keyword\">in</span> enumerate(encrypted):</span><br><span class=\"line\">\t\t\ti = len(encrypted) - i - <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\"># print i</span></span><br><span class=\"line\">\t\t\ttmp += chr((((ord(b) ^ key &amp; <span class=\"number\">0xff</span>) ^ ord(num[(i % len(num))])) &amp; <span class=\"number\">0xff</span>))</span><br><span class=\"line\">\t\tencrypted = tmp</span><br><span class=\"line\">\tflag = encrypted</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> flag</span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">32</span>, <span class=\"number\">126</span>):</span><br><span class=\"line\">\t\t<span class=\"keyword\">print</span> chr(i)</span><br><span class=\"line\">\t\tres = decrypt(i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">print</span> res[::<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<p>flag如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a</span><br><span class=\"line\">flag&#123;ocean_of_junks_zzz&#125;</span><br></pre></td></tr></table></figure>\n","categories":[],"tags":[{"name":"RE","slug":"RE","count":2,"path":"api/tags/RE.json"}]}