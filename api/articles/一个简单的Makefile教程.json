{"title":"一个简单的Makefile教程","slug":"一个简单的Makefile教程","date":"2018-11-19T14:31:41.000Z","updated":"2018-11-19T15:38:42.000Z","comments":true,"path":"api/articles/一个简单的Makefile教程.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p>Makefile是一种组织代码编译的简单方法。这个教程将会指导你编写中小规模项目的makefile文件。</p>\n<h2 id=\"0x00-一个简单的例子\"><a href=\"#0x00-一个简单的例子\" class=\"headerlink\" title=\"0x00  一个简单的例子\"></a>0x00  一个简单的例子</h2><p>让我们首先引入下面这三个文件，hellomake.c，hellofunc.c，hellomake.h：三者组成一个标准的C程序。</p>\n<p><code>hellomake.c</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;hellomake.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// call a function in another file</span></span><br><span class=\"line\">    myPrintHelloMake();</span><br><span class=\"line\">    <span class=\"keyword\">return</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>hellofunc.c</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;hellomake.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myPrintHelloMake</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello makefiles!\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>hellomake.h</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">example include file</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myPrintHelloMake</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br></pre></td></tr></table></figure>\n<p>一般地，可以通过下面的指令编译这些代码</p>\n<p><code>gcc -o hellomake hellomake.c hellofunc.c -I.</code></p>\n<p>这将编译两个.c文件 hellomake.c、hellofunc.c，并且指定可执行文件的名字为hellomake。-I dir是指定搜索头文件的目录的路径为dir，而-I.是指定在当前目录下寻找。没有makefile的话，为了重复测试/修改/调试你的代码，常见的做法是用上方向键在终端中找到上一条指令，因而你就不用每次重新输入指令。</p>\n<p>不幸的是，这种做法有两个弊端。第一，如果你弄丢了编译指令或者换了一台计算机，你将不得不重新输入，导致效率极低。第二，如果你只修改了一个.c文件，每次都重新编译所有的文件也是耗时且低效的。因此，我们需要学习如何使用makefile。</p>\n<h2 id=\"0x01-Makefile1\"><a href=\"#0x01-Makefile1\" class=\"headerlink\" title=\"0x01  Makefile1\"></a>0x01  Makefile1</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hellomake: hellomake.c hellofunc.c</span><br><span class=\"line\">\tgcc -o hellomake hellomake.c hellofunc.c -I.</span><br></pre></td></tr></table></figure>\n<p>将上述规则（rule）写到文件Makefile或makefile中，放在同一路径下，然后键入make就可以执行相应的编译。另外，通过将指令所需要的文件列在第一行的冒号之后，make会知道规则hellomake在这些文件之一被修改时需要被执行。此时，你已经解决了问题1——不需要再使用上方向键了。</p>\n<p><em>gcc指令之前需要有一个tab，而且在任何指令之前必须有一个tab。(必须是tab不能是空格)</em></p>\n<h2 id=\"0x02-Makefile2\"><a href=\"#0x02-Makefile2\" class=\"headerlink\" title=\"0x02  Makefile2\"></a>0x02  Makefile2</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CC=gcc</span><br><span class=\"line\">CFLAGS=-I.</span><br><span class=\"line\"></span><br><span class=\"line\">hellomake: hellomake.o hellofunc.o</span><br><span class=\"line\">\t$(CC) -o hellomake hellomake.o hellofunc.o</span><br></pre></td></tr></table></figure>\n<p>现在你已经定义了一些常量CC和CFLAGS。这些特殊的常量将告诉make指令我们将如何编译文件hellomake.c和hellofunc.c。特别地，CC表明所使用的C编译器，CFLAGS表明传递给编译器的参数。通过将目标文件——hellomake.o和hellofunc.o放在依赖列表和规则中，make知道它必须首先独立的编译.c为.o，然后将他们编译成一个可执行文件hellomake。</p>\n<p>使用这个形式的makefile对大多数小规模的项目十分有效。然而，头文件的依赖被遗忘了。举例来说，如果我们修改了hellomake.h，make将不会重新编译.c文件，即使它需要这么做。为了解决这个问题，我们需要指明.c文件所依赖的.h文件。通过再编写一个简单的规则并且添加进makefile中可以达成目的。</p>\n<h2 id=\"0x03-Makefile3\"><a href=\"#0x03-Makefile3\" class=\"headerlink\" title=\"0x03  Makefile3\"></a>0x03  Makefile3</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CC=gcc</span><br><span class=\"line\">CFLAGS=-I.</span><br><span class=\"line\">DEPS=hellomake.h</span><br><span class=\"line\"></span><br><span class=\"line\">%.o: %.c $(DEPS)</span><br><span class=\"line\">\t$(CC) -c -o <span class=\"variable\">$@</span> $&lt; $(CFLAGS)</span><br><span class=\"line\"></span><br><span class=\"line\">hellomake: hellomake.o hellofunc.o</span><br><span class=\"line\">\t$(CC) -o hellomake hellomake.o hellofunc.o</span><br></pre></td></tr></table></figure>\n<p>这个例子首先定义了一个叫DEPS的变量，表示.c文件所依赖的头文件的集合。然后定义了一个规则应用于所有.o后缀的文件。这个规则指定每个.o文件依赖于相应的.c文件和DEPS所表示的.h文件。-c参数指定产生.o文件，-o $@说明将编译结果输出在<strong>冒号左边</strong>的名字的文件中，$&lt;是<strong>依赖列表中的第一个文件</strong>（即.c文件），最后加上其它编译参数。</p>\n<p>make执行的命令序列如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -c -o hellomake.o hellomake.c -I.</span><br><span class=\"line\">gcc -c -o hellofunc.o hellofunc.c -I.</span><br><span class=\"line\">gcc -o hellomake hellomake.o hellofunc.o</span><br></pre></td></tr></table></figure>\n<p>为了最终简化，我们使用特殊的宏$@和$^使得编译规则更加普适化。</p>\n<p>$@表示冒号的左端、$^表示冒号的右端，$&lt;表示依赖列表中第一个文件</p>\n<h2 id=\"0x04-Makefile4\"><a href=\"#0x04-Makefile4\" class=\"headerlink\" title=\"0x04  Makefile4\"></a>0x04  Makefile4</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CC=gcc</span><br><span class=\"line\">CFLAGS=-I.</span><br><span class=\"line\">DEPS=hellomake.h</span><br><span class=\"line\">OBJ=hellomake.o hellofunc.o</span><br><span class=\"line\"></span><br><span class=\"line\">%.o: %.c $(DEPS)</span><br><span class=\"line\">\t$(CC) -c -o <span class=\"variable\">$@</span> $&lt; $(CFLAGS)</span><br><span class=\"line\">\t</span><br><span class=\"line\">hellomake: $(OBJ)</span><br><span class=\"line\">\t$(CC) -o <span class=\"variable\">$@</span> $^ $(CFLAGS)</span><br></pre></td></tr></table></figure>\n<p>那如果我们想将.h文件放到include目录中，将源文件放到src目录中，将一些库放在lib目录中呢？此外，我们可以采用某种方法隐藏（其实只是一种障眼法hhh）那些无处不在的讨厌的.o文件吗？答案当然是可以的。下面这个makefile定义了src和lib目录的路径，并且将目标文件集中放在src目录下的obj子目录中。它也定义了表示所要包含的库的变量，例如数学库-lm。这个makefile需要放在src目录下。最后，定义了make clean的规则。</p>\n<h2 id=\"0x05-Makefile5\"><a href=\"#0x05-Makefile5\" class=\"headerlink\" title=\"0x05 Makefile5\"></a>0x05 Makefile5</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IDIR=../include</span><br><span class=\"line\">CC=gcc</span><br><span class=\"line\">CFLAGS=-I$(IDIR)</span><br><span class=\"line\"></span><br><span class=\"line\">ODIR=obj</span><br><span class=\"line\">LDIR=../lib</span><br><span class=\"line\"></span><br><span class=\"line\">LIBS=-lm</span><br><span class=\"line\"></span><br><span class=\"line\">_DEP=hellomake.h</span><br><span class=\"line\">DEPS=$(patsubst %,$(IDIR)/%,$(_DEP))</span><br><span class=\"line\"></span><br><span class=\"line\">_OBJ=hellomake.o hellofunc.o</span><br><span class=\"line\">OBJ=$(patsubst %,$(ODIR)/%,$(_OBJ))</span><br><span class=\"line\"></span><br><span class=\"line\">$(ODIR)/%.o: %.c $(DEPS)</span><br><span class=\"line\">\t$(CC) -c -o <span class=\"variable\">$@</span> $&lt; $(CFLAGS)</span><br><span class=\"line\">hellomake: $(OBJ)</span><br><span class=\"line\">\t$(CC) -o <span class=\"variable\">$@</span> $^ $(CFLAGS) $(LIBS)</span><br><span class=\"line\">\t</span><br><span class=\"line\">.PHONY: clean</span><br><span class=\"line\"></span><br><span class=\"line\">clean:</span><br><span class=\"line\">\trm -f $(ODIR)/*.o hellomake</span><br></pre></td></tr></table></figure>\n<p>.PHONY规则是为了避免二义性。</p>\n<p>另外，patsubstd的定义如下： <code>$(patsubst pattern,replacement,text)</code></p>\n<p>从text中寻找按空格划分的单词中符合pattern的，然后用replacement替换掉它。pattern可能包含一个’%’作为通配符，匹配单词中任何数量的字符。如果replacement中也包含’%’，则这个’%’会被pattern的’%’所匹配的内容所替换。</p>\n<p>##0x06  总结</p>\n<p>总之，编写一个makefile重点就是定义一些变量和一些规则，规则格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">targets : prerequisites</span><br><span class=\"line\">\trecipe</span><br><span class=\"line\">\t...</span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">targets : prerequisites ; recipe</span><br><span class=\"line\">\trecipe</span><br><span class=\"line\">\t...</span><br></pre></td></tr></table></figure>\n<p>大体上，先明确头文件，再写.o的生成规则，最后写二进制文件的生成规则即可。</p>\n<p>当然，还包括一些导向(directive)指令，主要包括：</p>\n<ul>\n<li>包含其它makefile文件</li>\n<li>控制语句</li>\n<li>定义多行变量</li>\n</ul>\n<p>理解了这些，对于中小规模的项目来说，编写一个makefile文件是非常容易的。当然，如果使用CMAKE，可能会更加便利，但是也需要额外的学习成本。</p>\n<blockquote>\n<p><a href=\"http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/\" target=\"_blank\" rel=\"noopener\">参考链接</a></p>\n</blockquote>\n","categories":[],"tags":[{"name":"Dev","slug":"Dev","count":2,"path":"api/tags/Dev.json"}]}