{"title":"调试并解决Python内存泄露问题","slug":"调试并解决Python内存泄露问题","date":"2018-11-05T13:46:33.000Z","updated":"2018-11-06T06:00:12.000Z","comments":true,"path":"api/articles/调试并解决Python内存泄露问题.json","photos":[],"link":"","excerpt":null,"covers":["https://i.imgur.com/zkbTrwr.png"],"content":"<p>0x00  问题引入<br>虽然Python本身有垃圾回收机制，但是也有内存泄露的可能。这里我对这次调试项目代码的经验作简单总结，予以参考。</p>\n<p>一般来说，可能出现内存泄露的情况，有如下几种：<br>1.对象被全局变量所引用，而生命周期较长<br>2.gc被禁用，使用<code>gc.disabled()</code>和<code>gc.enable()</code>进行操作<br>3.变量的循环引用。一般来说，只要开启gc，即使存在变量的循环引用，也不会导致内存泄露。但如果对象属于不可回收的，就无法处理。不可回收的变量通过<code>gc.garbage</code>查看，实际上就是实现了<code>__del__()</code>方法的对象</p>\n<p>python的官方文档中对garbage方法的说明如下：</p>\n<blockquote>\n<p>A list of objects which the collector found to be unreachable but could not be freed (uncollectable objects). By default, this list contains only objects with <code>__del__()</code> methods. [1] Objects that have <code>__del__()</code> methods and are part of a reference cycle cause the entire reference cycle to be uncollectable, including objects not necessarily in the cycle but reachable only from it. Python doesn’t collect such cycles automatically because, in general, it isn’t possible for Python to guess a safe order in which to run the <code>__del__()</code> methods. </p>\n</blockquote>\n<p>简单解释一下，垃圾回收器会将不可达但不能被释放的对象标识为garbage。默认garbage列表只包含实现了<code>__del__()</code>方法的对象，这些对象属于一个循环引用的话会导致整个循环引用变得不可被回收。Python不会自动地回收这些循环，因为基本上Python不可能猜到真正安全的执行<code>__del__()</code>方法的顺序。当然如果你自己知道如何处理，可以用类似<code>del gc.garbage[:]</code>的方法在循环结束后手动释放。</p>\n<hr>\n<p>0x01  辅助工具</p>\n<p>首先推荐安装第三方工具Pyrasite，它可以在Python进程动态运行时修改数据和代码等，这显然有利于我们调试内存泄漏问题。它的最新版安装需要gdb(7.3版本以上)和Python2.4以上的环境。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(sudo) pip install pyrasite pyrasite-gui</span><br></pre></td></tr></table></figure></p>\n<p>如果操作系统是Ubuntu10.10以上，需要首先执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo 0 &gt; /proc/sys/kernel/yama/ptrace_scope</span><br></pre></td></tr></table></figure></p>\n<p>也可以通过设置<code>/etc/sysctl.d/10-ptrace.conf</code>中ptrace_scope为0来永久修改</p>\n<p>我们主要用到的是pyrasite-shell和pyrasite-memory-viewer。其中pyrasite-shell的用法如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pyrasite-shell</span><br><span class=\"line\">Usage: pyrasite-shell &lt;PID&gt;</span><br></pre></td></tr></table></figure></p>\n<p>输入相应Python进程的pid，得到一个shell与其进行交互，这个shell类似ipython。我们首先让存在内存泄漏问题的Python脚本运行起来，然后用pyrasite-shell getshell，就可以输入一些命令观察结果，从而定位问题。<br>pyrasite-memory-viewer则需首先安装urwid和meliae：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(sudo) pip install urwid meliae</span><br><span class=\"line\"></span><br><span class=\"line\">$ pyrasite-memory-viewer &lt;PID&gt;</span><br></pre></td></tr></table></figure></p>\n<p>界面会列出当前对象内存占用的统计，按占用大小排序，包含对象的数量、总大小、百分比、对象类型名等信息，点选单个对象后将打印出对象的内容</p>\n<hr>\n<p>0x02  调试过程</p>\n<p>首先将我们的Python程序运行起来，然后用pyrasite-shell注入。<br>首先用gc模块的相关方法查看是否是垃圾回收的问题<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Connected to &apos;python xxx.py&apos;</span><br><span class=\"line\">Python 2.7.12 (default, Dec  4 2017, 14:50:18) </span><br><span class=\"line\">[GCC 5.4.0 20160609] on linux2</span><br><span class=\"line\">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class=\"line\">(DistantInteractiveConsole)</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; import gc</span><br><span class=\"line\">&gt;&gt;&gt; gc.isenabled()</span><br><span class=\"line\">True</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; gc.garbage</span><br><span class=\"line\">[&lt;PtraceProcess #15277&gt;, &lt;PtraceProcess #15282&gt;, &lt;PtraceProcess #15287&gt;, &lt;PtraceProcess #15292&gt;, &lt;PtraceProcess #15297&gt;, &lt;PtraceProcess #15302&gt;, </span><br><span class=\"line\">&lt;PtraceProcess #15307&gt;, &lt;PtraceProcess #15312&gt;, &lt;PtraceProcess #15317&gt;,  .......</span><br></pre></td></tr></table></figure></p>\n<p>说明垃圾回收已开启，但多执行几次gc.garbage，发现这个叫做PtraceProcess的对象的数量在不断增加。实际上，这个对象是第三方python-ptrace模块中所定义的，查看其源码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def __del__(self):</span><br><span class=\"line\">        try:</span><br><span class=\"line\">            self.detach()</span><br><span class=\"line\">        except PtraceError:</span><br><span class=\"line\">            pass</span><br></pre></td></tr></table></figure></p>\n<p>果然定义了<code>__del__()</code>方法，这里可以使用objgraph模块作出此对象的循环引用图，从而直观的判断到底是哪里出现问题。具体安装和使用方法并不复杂，这里不再赘述，只给出样例图。<br><img src=\"https://i.imgur.com/zkbTrwr.png\" alt></p>\n<p>但是，在我将PtraceProcess的<code>__del__()</code>方法注释掉之后，问题仍然存在。这令我有些费解，这时想到去研究一下linux自带的top命令。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top - 13:24:30 up 2 days, 11:37,  1 user,  load average: 0.54, 0.82, 0.93</span><br><span class=\"line\">Tasks: 286 total,   1 running, 285 sleeping,   0 stopped,   0 zombie</span><br><span class=\"line\">%Cpu(s):  6.1 us,  5.8 sy,  0.0 ni, 87.7 id,  0.1 wa,  0.0 hi,  0.3 si,  0.0 st</span><br><span class=\"line\">KiB Mem :  4016440 total,   249140 free,  2123672 used,  1643628 buff/cache</span><br><span class=\"line\">KiB Swap:  4192252 total,  4175600 free,    16652 used.  1304868 avail Mem </span><br><span class=\"line\"></span><br><span class=\"line\">   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                           </span><br><span class=\"line\"> 32514 liwc      20   0  247852  52012   7468 S  69.1  1.3   0:08.44 python</span><br></pre></td></tr></table></figure></p>\n<p>可以看到%MEM、VIRT、RES、SHR这几项都在不断地增大，其中%MEM顾名思义就是内存的占用量，而VIRT是进程使用的虚拟内存总量、RES是进程使用的、未被换出的物理内存大小，SHR是以共享方式使用的内存大小。因为项目代码使用了用shmget申请的共享内存，所以我格外关注SHR的含义。通过查找资料得知，SHR包括：</p>\n<blockquote>\n<p>程序的代码段<br>动态库的代码段<br>通过mmap做的文件映射<br>通过mmap做的匿名映射，但指明了MAP_SHARED属性<br>通过shmget申请的共享内存</p>\n</blockquote>\n<p>在大佬的提示下，又发现内存增长的总量全部来自于SHR部分，这不禁使我怀疑是该部分代码有问题。使用pmap指令查看进程的内存映射关系:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">97523:   python xxx.py</span><br><span class=\"line\">0000000000400000   2936K r-x-- python2.7</span><br><span class=\"line\">00000000008dd000      4K r---- python2.7</span><br><span class=\"line\">00000000008de000    476K rw--- python2.7</span><br><span class=\"line\">0000000000955000    140K rw---   [ anon ]</span><br><span class=\"line\">0000000000b7a000  33564K rw---   [ anon ]</span><br><span class=\"line\">00007f6465c10000     64K rw-s-   [ shmid=0x6aac8bca ]</span><br><span class=\"line\">00007f6465c20000     64K rw-s-   [ shmid=0x6aac8bca ]</span><br><span class=\"line\">00007f6465c30000     64K rw-s-   [ shmid=0x6aac8bca ]</span><br><span class=\"line\">...</span><br><span class=\"line\">00007f6479e93000     64K rw-s-   [ shmid=0x6aac8bca ]</span><br><span class=\"line\">00007f6479ea3000      4K -----   [ anon ]</span><br><span class=\"line\">00007f6479ea4000   8192K rw---   [ anon ]</span><br><span class=\"line\">...</span><br><span class=\"line\"> total           447084K</span><br></pre></td></tr></table></figure></p>\n<p>发现同一块用shmget申请的共享内存被映射到进程空间内数次，看来这个就是吃掉内存的元凶。事实上，就是shmat函数被错误地调用了多次，从而被映射了多次。修正代码后，问题解决。</p>\n<hr>\n<p>0x03  问题总结</p>\n<p>总之，感觉出现疑似内存泄漏时，应该首先用pyrasite-shell连上看一下，排除循环引用等垃圾回收的问题，同时注意观察pmap、top等命令的结果。</p>\n","categories":[],"tags":[{"name":"Dev","slug":"Dev","count":2,"path":"api/tags/Dev.json"}]}