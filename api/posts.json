{"total":16,"pageSize":10,"pageCount":2,"data":[{"title":"模糊测试与程序分析","slug":"program-analysis-and-fuzzing","date":"2020-04-08T17:05:58.000Z","updated":"2020-04-08T17:18:58.898Z","comments":true,"path":"api/articles/program-analysis-and-fuzzing.json","excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文基于笔者对模糊测试和程序分析的粗浅理解，如有谬误，欢迎斧正。另外，如转载、引用本文，请注明出处，谢谢！</p>\n<h2 id=\"模糊测试概述\"><a href=\"#模糊测试概述\" class=\"headerlink\" title=\"模糊测试概述\"></a>模糊测试概述</h2><p>模糊测试（Fuzzing test）是当前工业界和学术界公认最有效的漏洞挖掘方法。维基百科上的定义如下：模糊测试是一种软件测试技术。其核心思想是将自动或半自动生成的随机数据输入到一个程序中，并监视程序异常，如崩溃，断言（assertion）失败，以发现可能的程序错误，比如内存泄漏等。</p>\n<p>模糊测试有多种分类指标，按照产生针对目标系统的输入的方式不同，可分为基于生成的模糊测试和基于变异的模糊测试。前者适用于目标输入格式已知或逆向可得的场景，需要使用者构建一个模版，模糊测试器基于模版不断生成测试用例；后者则要求使用者提供一个或数个种子文件，然后模糊测试器利用内置的算法逻辑对种子进行变异，从而快速生成大量测试用例。按照对目标程序或计算机系统的所掌握的信息量区分，可分为黑盒模糊测试、白盒模糊测试和灰盒模糊测试。黑盒模糊测试在是目标程序的源代码难以获取，或者可获取但不对源代码进行分析时，只对二进制程序进行测试的一类方法。白盒模糊测试需要借助重量级的程序分析方法，例如符号执行和约束求解，从而降低模糊测试的盲目性并提高覆盖率。灰盒模糊测试介于两者之间，一般采用在编译时插装的方法对源代码进行轻量级的分析，同时保持运行时的性能以期发现更多的安全漏洞。</p>\n<h2 id=\"典型模糊测试工具\"><a href=\"#典型模糊测试工具\" class=\"headerlink\" title=\"典型模糊测试工具\"></a>典型模糊测试工具</h2><p>Michal Zalewski于2014年发布了开源项目AFL，公认为模糊测试领域的一大里程碑。AFL是一款基于变异的灰盒模糊测试器，在用GCC/LLVM对目标程序源代码编译时进行插装，使插装后的程序在动态运行时将路径覆盖信息加载到共享内存，最终模糊测试器可以获取每个变异后种子的边覆盖信息。AFL以边覆盖为反馈信息，基于遗传算法维护一个种子队列，只将标记为有趣的种子放入种子队列。通过上述策略，AFL能够在保持高运行速率的前提下充分提高覆盖率，提高漏洞挖掘的效率与几率。另外，AFL还有基于QEMU的二进制插装解决方案，能够对闭源软件进行覆盖引导的模糊测试 。目前为止，AFL已经发现了开源软件和部分闭源软件中的成千上百个漏洞，包括广泛使用的开源库ffmpeg、curl等和应用程序IE、Firefox等。</p>\n<p>Google后来推出了集成在LLVM框架中的覆盖反馈模糊测试组件LibFuzzer，它与AFL的主体算法相似，但是模糊测试的目标不是待测程序，而是可局部执行的代码片段，这提高了模糊测试的可扩展性，也避免运行非攻击面的代码所造成的额外开销。Google基于LibFuzzer构建了OSS-Fuzz模糊测试系统，对托管在该系统上的开源软件进行持续性的模糊测试，在五个月内从47个开源项目中发现了1000多个bug。</p>\n<h2 id=\"AFL的改进面\"><a href=\"#AFL的改进面\" class=\"headerlink\" title=\"AFL的改进面\"></a>AFL的改进面</h2><p>以AFL、honggfuzz、LibFuzzer为代表的基于变异的灰盒模糊测试器由于其实用性被安全研究人员广泛应用于漏洞挖掘的真实场景中，而在各大安全与软工顶会中也涌现出一批以AFL为基线的工作。这些工作大都对AFL已有的算法与机制进行改进，以适配不同的应用场景。一般来说，模糊测试的目的是为了发现更多的缺陷与安全漏洞，而通常人们用提高覆盖率来近似拟合增加漏洞发现几率。原始的AFL代码整理出一套可行的解决方案，但在其运转的各个环节仍有许多改进面可以提高代码覆盖率。具体来说，主要有如下两点：</p>\n<h3 id=\"1-种子排序、种子打分等种子队列循环调度机制\"><a href=\"#1-种子排序、种子打分等种子队列循环调度机制\" class=\"headerlink\" title=\"1. 种子排序、种子打分等种子队列循环调度机制\"></a>1. 种子排序、种子打分等种子队列循环调度机制</h3><p>AFLfast（CCS’16）中证明了覆盖反馈的灰盒模糊测试可以建模为<strong>马尔可夫链</strong>。<strong>设状态i是程序中的某条分支路径，从状态i到状态j的转移概率pij由模糊测试由执行路径i的种子变异产生执行路径j的种子的概率给出</strong>。该工作通过调整种子打分（得分越高，变异次数越多）机制，在原始得分上增加能量调度，将模糊测试过程引向低频路径，从而在短时间内获得高覆盖率。</p>\n<p>另外，由于AFL内部维护一个种子队列，而该队列中的元素按照优先级排序。如果能够合理调整种子的优先级，使得应当具有高优先级的种子被优先处理，那么也能显著的提高模糊测试效率。</p>\n<h3 id=\"2-变异位置，变异策略等种子变异机制\"><a href=\"#2-变异位置，变异策略等种子变异机制\" class=\"headerlink\" title=\"2. 变异位置，变异策略等种子变异机制\"></a>2. 变异位置，变异策略等种子变异机制</h3><p>原始的AFL具有丰富的变异策略，又保持了很强的随机性，这在漏洞挖掘实践中被证明是有效的。但是，对于路径较深、触发较难的漏洞，这种随机变异为主的方法可能看起来是在赌博。如果我们能针对目标问题增加一些启发式算法，甚至用白盒方法获取一些知识指导变异，从而控制变异的位置和变异的策略，那么自然能提高代码覆盖率，增加模糊测试器的漏洞挖掘能力。</p>","keywords":null,"cover":null,"content":null,"text":"前言本文基于笔者对模糊测试和程序分析的粗浅理解，如有谬误，欢迎斧正。另外，如转载、引用本文，请注明出处，谢谢！模糊测试概述模糊测试（Fuzzing test）是当前工业界和学术界公认最有效的漏洞挖掘方法。维基百科上的定义如下：模糊测试是一种软件测试技术。其核心思想是将自动或半自动","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"fuzzing","slug":"fuzzing","count":1,"path":"api/tags/fuzzing.json"}]},{"title":"Google Project博客翻译——关于Adobe符号的二三事","slug":"Google-Project博客翻译——关于Adobe符号的二三事","date":"2020-03-04T08:22:59.000Z","updated":"2020-04-08T17:17:27.807Z","comments":true,"path":"api/articles/Google-Project博客翻译——关于Adobe符号的二三事.json","excerpt":"<h1 id=\"关于Adode-Reader符号的二三事\"><a href=\"#关于Adode-Reader符号的二三事\" class=\"headerlink\" title=\"关于Adode Reader符号的二三事\"></a>关于Adode Reader符号的二三事</h1><p>原文链接：<a href=\"https://googleprojectzero.blogspot.com/2019/10/the-story-of-adobe-reader-symbols.html\" target=\"_blank\" rel=\"noopener\">https://googleprojectzero.blogspot.com/2019/10/the-story-of-adobe-reader-symbols.html</a></p>\n<p>原文作者：Mateusz Jurczyk, Project Zero（j00ru）</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>当前针对客户端应用的安全分析通常由于难以获取源码和调试符号（debug symbols）等其他帮助信息而受到妨碍。因此，一般需要对目标软件进行纯黑盒的逆向工程，以便更好地理解它们的内部逻辑并恢复缺失的上下文信息，这对于识别安全缺陷、对崩溃（crash）进行归类和去重等是必要的。这一阶段可能会令人望而生畏，而花费在手工劳动上的时间相应地减少了测试程序的安全性的时间。换句话说，这可以被认为是在浪费时间。:-)</p>\n<p>另一方面，尽可能有效地利用所有可用资源来辅助研究是安全研究者自己的责任。对于发行历史悠久的成熟软件来说，例如可追溯到90年代的，可获取的资源应当包括旧版本的程序和/或当前支持平台之外的其他编译版本。尽管这些版本现在对于普通用户来说基本没用，它们却可能包含对漏洞猎人而言十分宝贵的元件。在很多情况下，多年来的应用程序内核代码都不会改变，或者仅有轻微变动。所以无论我们能找到什么辅助信息，至少在某种程度上，它们通常都适用于最新版本。基于上述原因，我建议所有的安全研究者在研究工作伊始开展额外的“调研”步骤，因为这将可能极大地节省后续的时间和精力。</p>\n<p>在本篇文章中，我将重点介绍在旧版本和少见版本的Adobe Reader中找到的元数据（metadata）。</p>","keywords":null,"cover":"/image/image-20200224163559287.png","content":null,"text":"关于Adode Reader符号的二三事原文链接：https://googleprojectzero.blogspot.com/2019/10/the-story-of-adobe-reader-symbols.html原文作者：Mateusz Jurczyk, Project ","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"漏洞挖掘","slug":"漏洞挖掘","count":1,"path":"api/tags/漏洞挖掘.json"}]},{"title":"无题","slug":"无题","date":"2019-12-06T08:12:49.000Z","updated":"2019-12-06T09:03:04.171Z","comments":true,"path":"api/articles/无题.json","excerpt":"","keywords":null,"cover":null,"content":"<p>最近好久没有更新博客，因为投入实验室里事情的精力较多，也没有太好的值得分享的点。</p>\n<p>但倒也刷了一些题目，由于writeup写的比较简单就不单独总结成博客了，感兴趣的可以参见我的<a href=\"https://github.com/1wc/ctfs\" target=\"_blank\" rel=\"noopener\">repo</a>。题目的质量都还不错，主要的收获有seccomp-tools分析沙箱、爆破ASLR、利用<code>IO_FILE</code>和libc中<code>stdout, stderr, stdin</code>的几个trick，<code>realloc</code>函数的利用等。</p>\n<p>另外，在挖洞方面，最近比较感兴趣的是Github收购的Codeql，因为个人感觉其在辅助review代码方面还是很方便的。我在Ubuntu下搭起环境简单地试用了一波，以后可能会写一篇文章单独分析。</p>\n","text":"最近好久没有更新博客，因为投入实验室里事情的精力较多，也没有太好的值得分享的点。但倒也刷了一些题目，由于writeup写的比较简单就不单独总结成博客了，感兴趣的可以参见我的repo。题目的质量都还不错，主要的收获有seccomp-tools分析沙箱、爆破ASLR、利用IO_FIL","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"contribute_to_Apache","slug":"contribute-to-Apache","date":"2019-10-16T07:52:42.000Z","updated":"2020-03-04T08:39:47.091Z","comments":true,"path":"api/articles/contribute-to-Apache.json","excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>由于实验室里项目需求等原因，笔者的硕士开题方向将会偏向大数据平台的安全。前些日子在调研历史CVE和issue过程中发现了一个有趣的访问控制问题，一开始尝试联系Apache安全团队但杳无音讯，最终考虑到问题的严重性比较低，于是决定提一个issue，成为contributer👋。</p>\n<p>整个流程还是比较麻烦的，而且网上没有找到比较好的中文资料，在此整理一下自己的思路，如有错误，欢迎斧正。</p>\n<p>p.s.: 本文所述的步骤主要基于Apache Sentry 的Wiki中的说明，其他项目或者会有少许不同。</p>","keywords":null,"cover":"/image/image-20191016170814599.png","content":null,"text":"前言由于实验室里项目需求等原因，笔者的硕士开题方向将会偏向大数据平台的安全。前些日子在调研历史CVE和issue过程中发现了一个有趣的访问控制问题，一开始尝试联系Apache安全团队但杳无音讯，最终考虑到问题的严重性比较低，于是决定提一个issue，成为contributer👋","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Dev","slug":"Dev","count":3,"path":"api/tags/Dev.json"},{"name":"Big Data","slug":"Big-Data","count":1,"path":"api/tags/Big-Data.json"}]},{"title":"数字经济云安全CTF","slug":"数字经济云安全CTF","date":"2019-09-24T13:27:08.000Z","updated":"2019-11-19T11:24:51.202Z","comments":true,"path":"api/articles/数字经济云安全CTF.json","excerpt":"<p>​    上周末跟着dl们混了一波所谓“数字经济云安全”众测大赛的比赛，最后队内的web师傅和misc师傅发挥神勇，而我和pwn的队友们则拖了后腿，所以只获得50名，着实有些可惜。虽然也算做出了一题半，但落实下来由于各种因素一面flag都没有得到，这值得我深刻反思。下面依次看一下两道pwn的题目。</p>\n<h2 id=\"amazon\"><a href=\"#amazon\" class=\"headerlink\" title=\"amazon\"></a>amazon</h2><h3 id=\"审计\"><a href=\"#审计\" class=\"headerlink\" title=\"审计\"></a>审计</h3><h4 id=\"buy\"><a href=\"#buy\" class=\"headerlink\" title=\"buy\"></a>buy</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> __<span class=\"function\">int64 <span class=\"title\">buy</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> number; <span class=\"comment\">// [rsp+4h] [rbp-1Ch]</span></span><br><span class=\"line\">  <span class=\"keyword\">size_t</span> nbytes; <span class=\"comment\">// [rsp+8h] [rbp-18h]</span></span><br><span class=\"line\">  __int64 count; <span class=\"comment\">// [rsp+10h] [rbp-10h]</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> __int64 v4; <span class=\"comment\">// [rsp+18h] [rbp-8h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v4 = __readfsqword(<span class=\"number\">0x28</span>u);</span><br><span class=\"line\">  put_names();</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"What item do you want to buy: \"</span>);</span><br><span class=\"line\">  __isoc99_scanf(<span class=\"string\">\"%d\"</span>, &amp;number);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( number &lt;= <span class=\"number\">3</span> )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"How many: \"</span>, &amp;number);</span><br><span class=\"line\">    __isoc99_scanf(<span class=\"string\">\"%lu\"</span>, &amp;count);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"How long is your note: \"</span>, &amp;count);</span><br><span class=\"line\">    __isoc99_scanf(<span class=\"string\">\"%d\"</span>, &amp;nbytes);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)nbytes &lt;= <span class=\"number\">0x100</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> ( HIDWORD(nbytes) = <span class=\"number\">0</span>; SHIDWORD(nbytes) &lt;= <span class=\"number\">47</span> &amp;&amp; qword_4080[SHIDWORD(nbytes)]; ++HIDWORD(nbytes) )</span><br><span class=\"line\">        ;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( HIDWORD(nbytes) != <span class=\"number\">48</span> )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        qword_4080[SHIDWORD(nbytes)] = (<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>((<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)(nbytes + <span class=\"number\">40</span>));</span><br><span class=\"line\">        <span class=\"built_in\">strcpy</span>(qword_4080[SHIDWORD(nbytes)], (&amp;off_4020)[number]);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Content: \"</span>);</span><br><span class=\"line\">        read(<span class=\"number\">0</span>, qword_4080[SHIDWORD(nbytes)] + <span class=\"number\">32</span>, (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)nbytes);</span><br><span class=\"line\">        *(_QWORD *)&amp;qword_4080[SHIDWORD(nbytes)][(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)nbytes + <span class=\"number\">32</span>] = count;</span><br><span class=\"line\">        <span class=\"built_in\">puts</span>(<span class=\"string\">\"Done!\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> __readfsqword(<span class=\"number\">0x28</span>u) ^ v4;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","keywords":null,"cover":null,"content":null,"text":"​    上周末跟着dl们混了一波所谓“数字经济云安全”众测大赛的比赛，最后队内的web师傅和misc师傅发挥神勇，而我和pwn的队友们则拖了后腿，所以只获得50名，着实有些可惜。虽然也算做出了一题半，但落实下来由于各种因素一面flag都没有得到，这值得我深刻反思。下面依次看一下","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"pwn","slug":"pwn","count":9,"path":"api/tags/pwn.json"}]},{"title":"2019护网杯_mergeheap","slug":"2019护网杯-mergeheap","date":"2019-09-10T12:24:26.000Z","updated":"2019-09-21T08:32:01.591Z","comments":true,"path":"api/articles/2019护网杯-mergeheap.json","excerpt":"<h1 id=\"mergeheap\"><a href=\"#mergeheap\" class=\"headerlink\" title=\"mergeheap\"></a>mergeheap</h1><h2 id=\"审计与分析\"><a href=\"#审计与分析\" class=\"headerlink\" title=\"审计与分析\"></a>审计与分析</h2><h3 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add\"></a>add</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">signed</span> <span class=\"keyword\">int</span> i; <span class=\"comment\">// [rsp+8h] [rbp-8h]</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> v2; <span class=\"comment\">// [rsp+Ch] [rbp-4h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">14</span> &amp;&amp; ptrs[i]; ++i )</span><br><span class=\"line\">    ;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( i &gt; <span class=\"number\">14</span> )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">\"full\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"len:\"</span>);</span><br><span class=\"line\">  v2 = read_num();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( v2 &lt; <span class=\"number\">0</span> || v2 &gt; <span class=\"number\">1024</span> )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">\"invalid\"</span>);</span><br><span class=\"line\">  ptrs[i] = <span class=\"built_in\">malloc</span>(v2);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"content:\"</span>);</span><br><span class=\"line\">  read_until_nil(ptrs[i], v2);</span><br><span class=\"line\">  dword_202060[i] = v2;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">\"Done\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最多14个堆块，大小在0到0x400之间，将每个堆块指针和堆块size存储在bss段上的全局数组处。</p>\n<h3 id=\"show\"><a href=\"#show\" class=\"headerlink\" title=\"show\"></a>show</h3><p>会输出对应堆块指针中的值。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">show</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> result; <span class=\"comment\">// eax</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> v1; <span class=\"comment\">// [rsp+Ch] [rbp-4h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"idx:\"</span>);</span><br><span class=\"line\">  v1 = read_num();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( v1 &gt;= <span class=\"number\">0</span> &amp;&amp; v1 &lt;= <span class=\"number\">14</span> &amp;&amp; ptrs[v1] )</span><br><span class=\"line\">    result = <span class=\"built_in\">puts</span>((<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *)ptrs[v1]);</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    result = <span class=\"built_in\">puts</span>(<span class=\"string\">\"invalid\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","keywords":null,"cover":null,"content":null,"text":"mergeheap审计与分析add1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>int add()<br>&#123","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"pwn","slug":"pwn","count":9,"path":"api/tags/pwn.json"}]},{"title":"CVE-2012-1876调试分析","slug":"CVE-2012-1876调试分析","date":"2019-07-10T12:19:25.000Z","updated":"2019-09-21T08:39:37.449Z","comments":true,"path":"api/articles/CVE-2012-1876调试分析.json","excerpt":"<h2 id=\"CVE-2012-1876\"><a href=\"#CVE-2012-1876\" class=\"headerlink\" title=\"CVE-2012-1876\"></a>CVE-2012-1876</h2><h3 id=\"1-漏洞简介\"><a href=\"#1-漏洞简介\" class=\"headerlink\" title=\"1. 漏洞简介\"></a>1. 漏洞简介</h3><p>一个IE漏洞，成功利用可RCE，问题在mshtml.dll模块的CTableLayout::CalculateMinMax函数中，程序在执行时会以HTML代码中\\元素的span属性作为循环控制次数向堆空间写入数据，如果此span值设置的不当，那么就会触发堆溢出问题。</p>\n<p>其中mshtml.dll模块是IE中的重要组件，用来解析HTML和CSS。（微软官方说明<a href=\"https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/aa741312(v=vs.85)）\" target=\"_blank\" rel=\"noopener\">https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/aa741312(v=vs.85)）</a></p>\n<p>系统：Win7 Pro x86</p>\n<p>版本：IE8.0.7601.17514</p>","keywords":null,"cover":"http://4.bp.blogspot.com/-xM3evabUguA/TlulZu6npaI/AAAAAAAAAB0/afhXWHrFcd0/s1600/spray_diagram.png","content":null,"text":"CVE-2012-18761. 漏洞简介一个IE漏洞，成功利用可RCE，问题在mshtml.dll模块的CTableLayout::CalculateMinMax函数中，程序在执行时会以HTML代码中\\元素的span属性作为循环控制次数向堆空间写入数据，如果此span值设置的不当","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"pwn","slug":"pwn","count":9,"path":"api/tags/pwn.json"}]},{"title":"2019CISCN_PWN(一)","slug":"2019CISCN-PWN-一","date":"2019-04-28T02:31:02.000Z","updated":"2019-09-21T08:32:43.789Z","comments":true,"path":"api/articles/2019CISCN-PWN-一.json","excerpt":"<h1 id=\"2019CISCN-PWN题解\"><a href=\"#2019CISCN-PWN题解\" class=\"headerlink\" title=\"2019CISCN_PWN题解\"></a>2019CISCN_PWN题解</h1><h2 id=\"0x00-Your-pwn\"><a href=\"#0x00-Your-pwn\" class=\"headerlink\" title=\"0x00  Your_pwn\"></a>0x00  Your_pwn</h2><h3 id=\"防护\"><a href=\"#防护\" class=\"headerlink\" title=\"防护\"></a>防护</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">liwc@ubuntu:~/pwn/2019_guosai/your_pwn$ checksec pwn</span><br><span class=\"line\">[*] &apos;/home/liwc/pwn/2019_guosai/your_pwn/pwn&apos;</span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    Canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>\n<p>RELRO没全开，其余全开</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>首先会向栈上写0x100，然后循环调用sub_B35函数。函数要求输入一个index，然后leak出从rbp - 0x150起的v4[index]的值，然后将值覆盖为要修改的值，也就是实现栈上的任意读写。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_<span class=\"function\">BOOL8 <span class=\"title\">sub_B35</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> index; <span class=\"comment\">// [rsp+4h] [rbp-15Ch]</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> v2; <span class=\"comment\">// [rsp+8h] [rbp-158h]</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> i; <span class=\"comment\">// [rsp+Ch] [rbp-154h]</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> v4[<span class=\"number\">64</span>]; <span class=\"comment\">// [rsp+10h] [rbp-150h]</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> s; <span class=\"comment\">// [rsp+50h] [rbp-110h]</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> __int64 v6; <span class=\"comment\">// [rsp+158h] [rbp-8h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v6 = __readfsqword(<span class=\"number\">0x28</span>u);</span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(&amp;s, <span class=\"number\">0</span>, <span class=\"number\">0x100</span>uLL);</span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(v4, <span class=\"number\">0</span>, <span class=\"number\">0x28</span>uLL);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">40</span>; ++i )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">\"input index\"</span>);</span><br><span class=\"line\">    __isoc99_scanf(<span class=\"string\">\"%d\"</span>, &amp;index);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"now value(hex) %x\\n\"</span>, (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)v4[index]);</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">\"input new value\"</span>);</span><br><span class=\"line\">    __isoc99_scanf(<span class=\"string\">\"%d\"</span>, &amp;v2);</span><br><span class=\"line\">    v4[index] = v2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">\"do you want continue(yes/no)? \"</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, &amp;s, <span class=\"number\">0x100</span>uLL);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">strncmp</span>(&amp;s, <span class=\"string\">\"yes\"</span>, <span class=\"number\">3u</span>LL) == <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"利用\"><a href=\"#利用\" class=\"headerlink\" title=\"利用\"></a>利用</h3><p>先leak出libc地址</p>\n<p>libc在rsp+0x280处，一开始输入的name在rsp + 0x170处，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gef➤  dereference $rsp</span><br><span class=\"line\">0x00007fffffffdc90│+0x0140: 0x0000000000000000</span><br><span class=\"line\">0x00007fffffffdc98│+0x0148: 0x0000000000000000</span><br><span class=\"line\">0x00007fffffffdca0│+0x0150: 0x0000000000000000</span><br><span class=\"line\">0x00007fffffffdca8│+0x0158: 0x82e23df75b4cba00</span><br><span class=\"line\">0x00007fffffffdcb0│+0x0160: 0x00007fffffffddd0  →  0x0000555555554ca0  →   push r15\t ← $rbp</span><br><span class=\"line\">0x00007fffffffdcb8│+0x0168: 0x0000555555554b11  →   test eax, eax</span><br><span class=\"line\">0x00007fffffffdcc0│+0x0170: 0x0000000a6377696c (&quot;liwc&quot;?)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">gef➤  dereference $rsp</span><br><span class=\"line\">0x00007fffffffddd0│+0x0280: 0x0000555555554ca0  →   push r15</span><br><span class=\"line\">0x00007fffffffddd8│+0x0288: 0x00007ffff7a2d830  →  &lt;__libc_start_main+240&gt; mov edi, eax</span><br></pre></td></tr></table></figure>\n<p>可以看到，在libc地址为0x7f766337c830时，leak出的值为ffffffc8，所以只需要删除ffffff即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x00007fffbaeeb878│+0x0288: 0x00007f765337c830  →  &lt;__libc_start_main+240&gt; mov edi, eax</span><br><span class=\"line\">[&apos;30&apos;, &apos;ffffffc8&apos;, &apos;37&apos;, &apos;53&apos;, &apos;76&apos;, &apos;7f&apos;, &apos;0&apos;, &apos;0&apos;]</span><br></pre></td></tr></table></figure>\n<p>最后直接把retn地址覆盖为one_gadget即可，直接绕过了canary，exp如下<br>","keywords":null,"cover":null,"content":null,"text":"2019CISCN_PWN题解0x00  Your_pwn防护1<br>2<br>3<br>4<br>5<br>6<br>7<br>liwc@ubuntu:~/pwn/2019_guosai/your_pwn$ checksec pwn<br>[*] &apos;/home/li","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"pwn","slug":"pwn","count":9,"path":"api/tags/pwn.json"}]},{"title":"Top Chunk利用","slug":"Top Chunk利用","date":"2019-04-21T02:58:07.000Z","updated":"2019-09-21T08:33:55.366Z","comments":true,"path":"api/articles/Top Chunk利用.json","excerpt":"<p>本文讲一下近期学习的两种围绕Top Chunk做文章的堆利用方法：House of Force和直接修改main_arena中的top指针。</p>\n<h2 id=\"House-of-force（Top-chunk劫持）\"><a href=\"#House-of-force（Top-chunk劫持）\" class=\"headerlink\" title=\"House of force（Top chunk劫持）\"></a>House of force（Top chunk劫持）</h2><h3 id=\"top-chunk的分割机制与利用点\"><a href=\"#top-chunk的分割机制与利用点\" class=\"headerlink\" title=\"top chunk的分割机制与利用点\"></a>top chunk的分割机制与利用点</h3><p>众所周知，top chunk的作用是作为后备堆空间，在各bin中没有chunk可提供时，分割出一个chunk提供给用户。那么这个分割过程是怎样的呢？我们来看一份源码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">victim = av-&gt;top;</span><br><span class=\"line\">size   = chunksize(victim);</span><br><span class=\"line\"><span class=\"keyword\">if</span> ((<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>) (size) &gt;= (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>) (nb + MINSIZE)) <span class=\"comment\">//检查请求size是否可以分配</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    remainder_size = size - nb; <span class=\"comment\">// 分配后size，此处nb为有符号数</span></span><br><span class=\"line\">    remainder      = chunk_at_offset(victim, nb); <span class=\"comment\">// 分配后指针</span></span><br><span class=\"line\">    av-&gt;top        = remainder; <span class=\"comment\">// top = 分配后的指针</span></span><br><span class=\"line\">    set_head(victim, nb | PREV_INUSE | <span class=\"comment\">// 设置PREV_INUSE和NON_MAIN_ARENA</span></span><br><span class=\"line\">            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class=\"number\">0</span>)); </span><br><span class=\"line\">    set_head(remainder, remainder_size | PREV_INUSE); <span class=\"comment\">//设置top</span></span><br><span class=\"line\"></span><br><span class=\"line\">    check_malloced_chunk(av, victim, nb);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *p = chunk2mem(victim);</span><br><span class=\"line\">    alloc_perturb(p, bytes);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先是libc会检查用户申请的大小，top chunk是否能给的起，如果给得起，就由top chunk的head处，以用户申请大小所匹配的chunk大小为偏移量，将top chunk的位置推到新的位置，而原来的top chunk head处就作为新的堆块被分配给用户了</p>\n<p>试想，如果我们能控制top chunk在这个过程中推到任意位置，也就是说，如果我们能控制用户申请的大小为任意值，我们就能将top chunk劫持到任意内存地址，然后就可以控制目标内存。</p>\n<p>一般来说，pwn中劫持控制流常常取malloc_hook, got表等指针，与堆空间中的top chunk相聚甚远，远到所需要申请的size必定超过top chunk现有的大小，无法控制if条件的检查。</p>\n<p>但是，我们看到if条件检查时size被强制转换为unsigned long，所以如果我们将size溢出覆盖为0xffffffff（-1），那么我们可以任意申请。此外，虽然此处的检查中，用户申请的大小也被当作无符号整数对待，但是在后面推top chunk的时候是以int对待的，所以可以劫持到低地址，加负数。</p>\n<h3 id=\"利用条件\"><a href=\"#利用条件\" class=\"headerlink\" title=\"利用条件\"></a>利用条件</h3><ul>\n<li>用户可以修改top chunk的size字段</li>\n<li>用户可以申请任意大小的堆内存（包括负数）</li>\n</ul>","keywords":null,"cover":null,"content":null,"text":"本文讲一下近期学习的两种围绕Top Chunk做文章的堆利用方法：House of Force和直接修改main_arena中的top指针。House of force（Top chunk劫持）top chunk的分割机制与利用点众所周知，top chunk的作用是作为后备堆空间","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"pwn","slug":"pwn","count":9,"path":"api/tags/pwn.json"}]},{"title":"DDCTF2019-writeup","slug":"DDCTF2019-writeup","date":"2019-04-18T11:41:06.000Z","updated":"2019-09-21T08:33:04.441Z","comments":true,"path":"api/articles/DDCTF2019-writeup.json","excerpt":"<p>本次DDCTF2019抱着玩一玩的心态参与了一下，事先不知道Pwn的题目这么少，RE的题目也不算多（主要RE的难题我不会做，简单题又比较水），所以就一开始做了两天，后续没有再尝试，最后排名100多位。下面简单总结一下Pwn和RE几道题的writeup。</p>\n<h1 id=\"Pwn\"><a href=\"#Pwn\" class=\"headerlink\" title=\"Pwn\"></a>Pwn</h1><p>pwn只有一道题目</p>\n<h2 id=\"Strike\"><a href=\"#Strike\" class=\"headerlink\" title=\"Strike\"></a>Strike</h2><p>该题目提供了libc，防护如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">liwc@ubuntu:~/pwn/DDCTF2019$ checksec xpwn </span><br><span class=\"line\">[*] &apos;/home/liwc/pwn/DDCTF2019/xpwn&apos;</span><br><span class=\"line\">    Arch:     i386-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>\n<p>未开启canary和PIE，只开启了NX，且为32位，有栈利用的可能。</p>\n<p>简单运行程序发现程序首先要求输入用户名，然后在打印用户名的时候会出现一些不可见字符，这里可能存在信息泄漏漏洞。之后要求输入密码的长度，再输入密码。用IDA简单查看下：</p>\n<p>在向栈上写name时，由于写完就用格式化字符串的%s格式输出，所以只要不输入\\x00，就可以随意leak出栈上的数据。</p>","keywords":null,"cover":null,"content":null,"text":"本次DDCTF2019抱着玩一玩的心态参与了一下，事先不知道Pwn的题目这么少，RE的题目也不算多（主要RE的难题我不会做，简单题又比较水），所以就一开始做了两天，后续没有再尝试，最后排名100多位。下面简单总结一下Pwn和RE几道题的writeup。Pwnpwn只有一道题目St","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"pwn","slug":"pwn","count":9,"path":"api/tags/pwn.json"},{"name":"RE","slug":"RE","count":2,"path":"api/tags/RE.json"}]}]}