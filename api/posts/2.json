{"total":11,"pageSize":10,"pageCount":2,"data":[{"title":"调试并解决Python内存泄露问题","slug":"调试并解决Python内存泄露问题","date":"2018-11-05T13:46:33.000Z","updated":"2019-09-21T08:37:34.344Z","comments":true,"path":"api/articles/调试并解决Python内存泄露问题.json","excerpt":"<p>0x00  问题引入<br>虽然Python本身有垃圾回收机制，但是也有内存泄露的可能。这里我对这次调试项目代码的经验作简单总结，予以参考。</p>\n<p>一般来说，可能出现内存泄露的情况，有如下几种：<br>1.对象被全局变量所引用，而生命周期较长<br>2.gc被禁用，使用<code>gc.disabled()</code>和<code>gc.enable()</code>进行操作<br>3.变量的循环引用。一般来说，只要开启gc，即使存在变量的循环引用，也不会导致内存泄露。但如果对象属于不可回收的，就无法处理。不可回收的变量通过<code>gc.garbage</code>查看，实际上就是实现了<code>__del__()</code>方法的对象</p>\n<p>python的官方文档中对garbage方法的说明如下：</p>\n<blockquote>\n<p>A list of objects which the collector found to be unreachable but could not be freed (uncollectable objects). By default, this list contains only objects with <code>__del__()</code> methods. [1] Objects that have <code>__del__()</code> methods and are part of a reference cycle cause the entire reference cycle to be uncollectable, including objects not necessarily in the cycle but reachable only from it. Python doesn’t collect such cycles automatically because, in general, it isn’t possible for Python to guess a safe order in which to run the <code>__del__()</code> methods. </p>\n</blockquote>\n<p>简单解释一下，垃圾回收器会将不可达但不能被释放的对象标识为garbage。默认garbage列表只包含实现了<code>__del__()</code>方法的对象，这些对象属于一个循环引用的话会导致整个循环引用变得不可被回收。Python不会自动地回收这些循环，因为基本上Python不可能猜到真正安全的执行<code>__del__()</code>方法的顺序。当然如果你自己知道如何处理，可以用类似<code>del gc.garbage[:]</code>的方法在循环结束后手动释放。</p>","keywords":null,"cover":null,"content":null,"text":"0x00  问题引入<br>虽然Python本身有垃圾回收机制，但是也有内存泄露的可能。这里我对这次调试项目代码的经验作简单总结，予以参考。一般来说，可能出现内存泄露的情况，有如下几种：<br>1.对象被全局变量所引用，而生命周期较长<br>2.gc被禁用，使用gc.disabl","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Dev","slug":"Dev","count":2,"path":"api/tags/Dev.json"}]}]}