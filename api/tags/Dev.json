{"name":"Dev","slug":"Dev","count":2,"postlist":[{"title":"一个简单的Makefile教程","slug":"一个简单的Makefile教程","date":"2018-11-19T14:31:41.000Z","updated":"2018-11-19T15:38:42.000Z","comments":true,"path":"api/articles/一个简单的Makefile教程.json","excerpt":"","keywords":null,"cover":null,"content":"<p>Makefile是一种组织代码编译的简单方法。这个教程将会指导你编写中小规模项目的makefile文件。</p>\n<h2 id=\"0x00-一个简单的例子\"><a href=\"#0x00-一个简单的例子\" class=\"headerlink\" title=\"0x00  一个简单的例子\"></a>0x00  一个简单的例子</h2><p>让我们首先引入下面这三个文件，hellomake.c，hellofunc.c，hellomake.h：三者组成一个标准的C程序。</p>\n<p><code>hellomake.c</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;hellomake.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// call a function in another file</span></span><br><span class=\"line\">    myPrintHelloMake();</span><br><span class=\"line\">    <span class=\"keyword\">return</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>hellofunc.c</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;hellomake.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myPrintHelloMake</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello makefiles!\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>hellomake.h</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">example include file</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myPrintHelloMake</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br></pre></td></tr></table></figure>\n<p>一般地，可以通过下面的指令编译这些代码</p>\n<p><code>gcc -o hellomake hellomake.c hellofunc.c -I.</code></p>\n<p>这将编译两个.c文件 hellomake.c、hellofunc.c，并且指定可执行文件的名字为hellomake。-I dir是指定搜索头文件的目录的路径为dir，而-I.是指定在当前目录下寻找。没有makefile的话，为了重复测试/修改/调试你的代码，常见的做法是用上方向键在终端中找到上一条指令，因而你就不用每次重新输入指令。</p>\n<p>不幸的是，这种做法有两个弊端。第一，如果你弄丢了编译指令或者换了一台计算机，你将不得不重新输入，导致效率极低。第二，如果你只修改了一个.c文件，每次都重新编译所有的文件也是耗时且低效的。因此，我们需要学习如何使用makefile。</p>\n<h2 id=\"0x01-Makefile1\"><a href=\"#0x01-Makefile1\" class=\"headerlink\" title=\"0x01  Makefile1\"></a>0x01  Makefile1</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hellomake: hellomake.c hellofunc.c</span><br><span class=\"line\">\tgcc -o hellomake hellomake.c hellofunc.c -I.</span><br></pre></td></tr></table></figure>\n<p>将上述规则（rule）写到文件Makefile或makefile中，放在同一路径下，然后键入make就可以执行相应的编译。另外，通过将指令所需要的文件列在第一行的冒号之后，make会知道规则hellomake在这些文件之一被修改时需要被执行。此时，你已经解决了问题1——不需要再使用上方向键了。</p>\n<p><em>gcc指令之前需要有一个tab，而且在任何指令之前必须有一个tab。(必须是tab不能是空格)</em></p>\n<h2 id=\"0x02-Makefile2\"><a href=\"#0x02-Makefile2\" class=\"headerlink\" title=\"0x02  Makefile2\"></a>0x02  Makefile2</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CC=gcc</span><br><span class=\"line\">CFLAGS=-I.</span><br><span class=\"line\"></span><br><span class=\"line\">hellomake: hellomake.o hellofunc.o</span><br><span class=\"line\">\t$(CC) -o hellomake hellomake.o hellofunc.o</span><br></pre></td></tr></table></figure>\n<p>现在你已经定义了一些常量CC和CFLAGS。这些特殊的常量将告诉make指令我们将如何编译文件hellomake.c和hellofunc.c。特别地，CC表明所使用的C编译器，CFLAGS表明传递给编译器的参数。通过将目标文件——hellomake.o和hellofunc.o放在依赖列表和规则中，make知道它必须首先独立的编译.c为.o，然后将他们编译成一个可执行文件hellomake。</p>\n<p>使用这个形式的makefile对大多数小规模的项目十分有效。然而，头文件的依赖被遗忘了。举例来说，如果我们修改了hellomake.h，make将不会重新编译.c文件，即使它需要这么做。为了解决这个问题，我们需要指明.c文件所依赖的.h文件。通过再编写一个简单的规则并且添加进makefile中可以达成目的。</p>\n<h2 id=\"0x03-Makefile3\"><a href=\"#0x03-Makefile3\" class=\"headerlink\" title=\"0x03  Makefile3\"></a>0x03  Makefile3</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CC=gcc</span><br><span class=\"line\">CFLAGS=-I.</span><br><span class=\"line\">DEPS=hellomake.h</span><br><span class=\"line\"></span><br><span class=\"line\">%.o: %.c $(DEPS)</span><br><span class=\"line\">\t$(CC) -c -o <span class=\"variable\">$@</span> $&lt; $(CFLAGS)</span><br><span class=\"line\"></span><br><span class=\"line\">hellomake: hellomake.o hellofunc.o</span><br><span class=\"line\">\t$(CC) -o hellomake hellomake.o hellofunc.o</span><br></pre></td></tr></table></figure>\n<p>这个例子首先定义了一个叫DEPS的变量，表示.c文件所依赖的头文件的集合。然后定义了一个规则应用于所有.o后缀的文件。这个规则指定每个.o文件依赖于相应的.c文件和DEPS所表示的.h文件。-c参数指定产生.o文件，-o $@说明将编译结果输出在<strong>冒号左边</strong>的名字的文件中，$&lt;是<strong>依赖列表中的第一个文件</strong>（即.c文件），最后加上其它编译参数。</p>\n<p>make执行的命令序列如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -c -o hellomake.o hellomake.c -I.</span><br><span class=\"line\">gcc -c -o hellofunc.o hellofunc.c -I.</span><br><span class=\"line\">gcc -o hellomake hellomake.o hellofunc.o</span><br></pre></td></tr></table></figure>\n<p>为了最终简化，我们使用特殊的宏$@和$^使得编译规则更加普适化。</p>\n<p>$@表示冒号的左端、$^表示冒号的右端，$&lt;表示依赖列表中第一个文件</p>\n<h2 id=\"0x04-Makefile4\"><a href=\"#0x04-Makefile4\" class=\"headerlink\" title=\"0x04  Makefile4\"></a>0x04  Makefile4</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CC=gcc</span><br><span class=\"line\">CFLAGS=-I.</span><br><span class=\"line\">DEPS=hellomake.h</span><br><span class=\"line\">OBJ=hellomake.o hellofunc.o</span><br><span class=\"line\"></span><br><span class=\"line\">%.o: %.c $(DEPS)</span><br><span class=\"line\">\t$(CC) -c -o <span class=\"variable\">$@</span> $&lt; $(CFLAGS)</span><br><span class=\"line\">\t</span><br><span class=\"line\">hellomake: $(OBJ)</span><br><span class=\"line\">\t$(CC) -o <span class=\"variable\">$@</span> $^ $(CFLAGS)</span><br></pre></td></tr></table></figure>\n<p>那如果我们想将.h文件放到include目录中，将源文件放到src目录中，将一些库放在lib目录中呢？此外，我们可以采用某种方法隐藏（其实只是一种障眼法hhh）那些无处不在的讨厌的.o文件吗？答案当然是可以的。下面这个makefile定义了src和lib目录的路径，并且将目标文件集中放在src目录下的obj子目录中。它也定义了表示所要包含的库的变量，例如数学库-lm。这个makefile需要放在src目录下。最后，定义了make clean的规则。</p>\n<h2 id=\"0x05-Makefile5\"><a href=\"#0x05-Makefile5\" class=\"headerlink\" title=\"0x05 Makefile5\"></a>0x05 Makefile5</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IDIR=../include</span><br><span class=\"line\">CC=gcc</span><br><span class=\"line\">CFLAGS=-I$(IDIR)</span><br><span class=\"line\"></span><br><span class=\"line\">ODIR=obj</span><br><span class=\"line\">LDIR=../lib</span><br><span class=\"line\"></span><br><span class=\"line\">LIBS=-lm</span><br><span class=\"line\"></span><br><span class=\"line\">_DEP=hellomake.h</span><br><span class=\"line\">DEPS=$(patsubst %,$(IDIR)/%,$(_DEP))</span><br><span class=\"line\"></span><br><span class=\"line\">_OBJ=hellomake.o hellofunc.o</span><br><span class=\"line\">OBJ=$(patsubst %,$(ODIR)/%,$(_OBJ))</span><br><span class=\"line\"></span><br><span class=\"line\">$(ODIR)/%.o: %.c $(DEPS)</span><br><span class=\"line\">\t$(CC) -c -o <span class=\"variable\">$@</span> $&lt; $(CFLAGS)</span><br><span class=\"line\">hellomake: $(OBJ)</span><br><span class=\"line\">\t$(CC) -o <span class=\"variable\">$@</span> $^ $(CFLAGS) $(LIBS)</span><br><span class=\"line\">\t</span><br><span class=\"line\">.PHONY: clean</span><br><span class=\"line\"></span><br><span class=\"line\">clean:</span><br><span class=\"line\">\trm -f $(ODIR)/*.o hellomake</span><br></pre></td></tr></table></figure>\n<p>.PHONY规则是为了避免二义性。</p>\n<p>另外，patsubstd的定义如下： <code>$(patsubst pattern,replacement,text)</code></p>\n<p>从text中寻找按空格划分的单词中符合pattern的，然后用replacement替换掉它。pattern可能包含一个’%’作为通配符，匹配单词中任何数量的字符。如果replacement中也包含’%’，则这个’%’会被pattern的’%’所匹配的内容所替换。</p>\n<p>##0x06  总结</p>\n<p>总之，编写一个makefile重点就是定义一些变量和一些规则，规则格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">targets : prerequisites</span><br><span class=\"line\">\trecipe</span><br><span class=\"line\">\t...</span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">targets : prerequisites ; recipe</span><br><span class=\"line\">\trecipe</span><br><span class=\"line\">\t...</span><br></pre></td></tr></table></figure>\n<p>大体上，先明确头文件，再写.o的生成规则，最后写二进制文件的生成规则即可。</p>\n<p>当然，还包括一些导向(directive)指令，主要包括：</p>\n<ul>\n<li>包含其它makefile文件</li>\n<li>控制语句</li>\n<li>定义多行变量</li>\n</ul>\n<p>理解了这些，对于中小规模的项目来说，编写一个makefile文件是非常容易的。当然，如果使用CMAKE，可能会更加便利，但是也需要额外的学习成本。</p>\n<blockquote>\n<p><a href=\"http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/\" target=\"_blank\" rel=\"noopener\">参考链接</a></p>\n</blockquote>\n","text":"Makefile是一种组织代码编译的简单方法。这个教程将会指导你编写中小规模项目的makefile文件。0x00  一个简单的例子让我们首先引入下面这三个文件，hellomake.c，hellofunc.c，hellomake.h：三者组成一个标准的C程序。hellomake.c","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Dev","slug":"Dev","count":2,"path":"api/tags/Dev.json"}]},{"title":"调试并解决Python内存泄露问题","slug":"调试并解决Python内存泄露问题","date":"2018-11-05T13:46:33.000Z","updated":"2018-11-06T06:00:12.000Z","comments":true,"path":"api/articles/调试并解决Python内存泄露问题.json","excerpt":"","keywords":null,"cover":"https://i.imgur.com/zkbTrwr.png","content":"<p>0x00  问题引入<br>虽然Python本身有垃圾回收机制，但是也有内存泄露的可能。这里我对这次调试项目代码的经验作简单总结，予以参考。</p>\n<p>一般来说，可能出现内存泄露的情况，有如下几种：<br>1.对象被全局变量所引用，而生命周期较长<br>2.gc被禁用，使用<code>gc.disabled()</code>和<code>gc.enable()</code>进行操作<br>3.变量的循环引用。一般来说，只要开启gc，即使存在变量的循环引用，也不会导致内存泄露。但如果对象属于不可回收的，就无法处理。不可回收的变量通过<code>gc.garbage</code>查看，实际上就是实现了<code>__del__()</code>方法的对象</p>\n<p>python的官方文档中对garbage方法的说明如下：</p>\n<blockquote>\n<p>A list of objects which the collector found to be unreachable but could not be freed (uncollectable objects). By default, this list contains only objects with <code>__del__()</code> methods. [1] Objects that have <code>__del__()</code> methods and are part of a reference cycle cause the entire reference cycle to be uncollectable, including objects not necessarily in the cycle but reachable only from it. Python doesn’t collect such cycles automatically because, in general, it isn’t possible for Python to guess a safe order in which to run the <code>__del__()</code> methods. </p>\n</blockquote>\n<p>简单解释一下，垃圾回收器会将不可达但不能被释放的对象标识为garbage。默认garbage列表只包含实现了<code>__del__()</code>方法的对象，这些对象属于一个循环引用的话会导致整个循环引用变得不可被回收。Python不会自动地回收这些循环，因为基本上Python不可能猜到真正安全的执行<code>__del__()</code>方法的顺序。当然如果你自己知道如何处理，可以用类似<code>del gc.garbage[:]</code>的方法在循环结束后手动释放。</p>\n<hr>\n<p>0x01  辅助工具</p>\n<p>首先推荐安装第三方工具Pyrasite，它可以在Python进程动态运行时修改数据和代码等，这显然有利于我们调试内存泄漏问题。它的最新版安装需要gdb(7.3版本以上)和Python2.4以上的环境。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(sudo) pip install pyrasite pyrasite-gui</span><br></pre></td></tr></table></figure></p>\n<p>如果操作系统是Ubuntu10.10以上，需要首先执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo 0 &gt; /proc/sys/kernel/yama/ptrace_scope</span><br></pre></td></tr></table></figure></p>\n<p>也可以通过设置<code>/etc/sysctl.d/10-ptrace.conf</code>中ptrace_scope为0来永久修改</p>\n<p>我们主要用到的是pyrasite-shell和pyrasite-memory-viewer。其中pyrasite-shell的用法如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pyrasite-shell</span><br><span class=\"line\">Usage: pyrasite-shell &lt;PID&gt;</span><br></pre></td></tr></table></figure></p>\n<p>输入相应Python进程的pid，得到一个shell与其进行交互，这个shell类似ipython。我们首先让存在内存泄漏问题的Python脚本运行起来，然后用pyrasite-shell getshell，就可以输入一些命令观察结果，从而定位问题。<br>pyrasite-memory-viewer则需首先安装urwid和meliae：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(sudo) pip install urwid meliae</span><br><span class=\"line\"></span><br><span class=\"line\">$ pyrasite-memory-viewer &lt;PID&gt;</span><br></pre></td></tr></table></figure></p>\n<p>界面会列出当前对象内存占用的统计，按占用大小排序，包含对象的数量、总大小、百分比、对象类型名等信息，点选单个对象后将打印出对象的内容</p>\n<hr>\n<p>0x02  调试过程</p>\n<p>首先将我们的Python程序运行起来，然后用pyrasite-shell注入。<br>首先用gc模块的相关方法查看是否是垃圾回收的问题<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Connected to &apos;python xxx.py&apos;</span><br><span class=\"line\">Python 2.7.12 (default, Dec  4 2017, 14:50:18) </span><br><span class=\"line\">[GCC 5.4.0 20160609] on linux2</span><br><span class=\"line\">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class=\"line\">(DistantInteractiveConsole)</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; import gc</span><br><span class=\"line\">&gt;&gt;&gt; gc.isenabled()</span><br><span class=\"line\">True</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; gc.garbage</span><br><span class=\"line\">[&lt;PtraceProcess #15277&gt;, &lt;PtraceProcess #15282&gt;, &lt;PtraceProcess #15287&gt;, &lt;PtraceProcess #15292&gt;, &lt;PtraceProcess #15297&gt;, &lt;PtraceProcess #15302&gt;, </span><br><span class=\"line\">&lt;PtraceProcess #15307&gt;, &lt;PtraceProcess #15312&gt;, &lt;PtraceProcess #15317&gt;,  .......</span><br></pre></td></tr></table></figure></p>\n<p>说明垃圾回收已开启，但多执行几次gc.garbage，发现这个叫做PtraceProcess的对象的数量在不断增加。实际上，这个对象是第三方python-ptrace模块中所定义的，查看其源码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def __del__(self):</span><br><span class=\"line\">        try:</span><br><span class=\"line\">            self.detach()</span><br><span class=\"line\">        except PtraceError:</span><br><span class=\"line\">            pass</span><br></pre></td></tr></table></figure></p>\n<p>果然定义了<code>__del__()</code>方法，这里可以使用objgraph模块作出此对象的循环引用图，从而直观的判断到底是哪里出现问题。具体安装和使用方法并不复杂，这里不再赘述，只给出样例图。<br><img src=\"https://i.imgur.com/zkbTrwr.png\" alt></p>\n<p>但是，在我将PtraceProcess的<code>__del__()</code>方法注释掉之后，问题仍然存在。这令我有些费解，这时想到去研究一下linux自带的top命令。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top - 13:24:30 up 2 days, 11:37,  1 user,  load average: 0.54, 0.82, 0.93</span><br><span class=\"line\">Tasks: 286 total,   1 running, 285 sleeping,   0 stopped,   0 zombie</span><br><span class=\"line\">%Cpu(s):  6.1 us,  5.8 sy,  0.0 ni, 87.7 id,  0.1 wa,  0.0 hi,  0.3 si,  0.0 st</span><br><span class=\"line\">KiB Mem :  4016440 total,   249140 free,  2123672 used,  1643628 buff/cache</span><br><span class=\"line\">KiB Swap:  4192252 total,  4175600 free,    16652 used.  1304868 avail Mem </span><br><span class=\"line\"></span><br><span class=\"line\">   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                           </span><br><span class=\"line\"> 32514 liwc      20   0  247852  52012   7468 S  69.1  1.3   0:08.44 python</span><br></pre></td></tr></table></figure></p>\n<p>可以看到%MEM、VIRT、RES、SHR这几项都在不断地增大，其中%MEM顾名思义就是内存的占用量，而VIRT是进程使用的虚拟内存总量、RES是进程使用的、未被换出的物理内存大小，SHR是以共享方式使用的内存大小。因为项目代码使用了用shmget申请的共享内存，所以我格外关注SHR的含义。通过查找资料得知，SHR包括：</p>\n<blockquote>\n<p>程序的代码段<br>动态库的代码段<br>通过mmap做的文件映射<br>通过mmap做的匿名映射，但指明了MAP_SHARED属性<br>通过shmget申请的共享内存</p>\n</blockquote>\n<p>在大佬的提示下，又发现内存增长的总量全部来自于SHR部分，这不禁使我怀疑是该部分代码有问题。使用pmap指令查看进程的内存映射关系:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">97523:   python xxx.py</span><br><span class=\"line\">0000000000400000   2936K r-x-- python2.7</span><br><span class=\"line\">00000000008dd000      4K r---- python2.7</span><br><span class=\"line\">00000000008de000    476K rw--- python2.7</span><br><span class=\"line\">0000000000955000    140K rw---   [ anon ]</span><br><span class=\"line\">0000000000b7a000  33564K rw---   [ anon ]</span><br><span class=\"line\">00007f6465c10000     64K rw-s-   [ shmid=0x6aac8bca ]</span><br><span class=\"line\">00007f6465c20000     64K rw-s-   [ shmid=0x6aac8bca ]</span><br><span class=\"line\">00007f6465c30000     64K rw-s-   [ shmid=0x6aac8bca ]</span><br><span class=\"line\">...</span><br><span class=\"line\">00007f6479e93000     64K rw-s-   [ shmid=0x6aac8bca ]</span><br><span class=\"line\">00007f6479ea3000      4K -----   [ anon ]</span><br><span class=\"line\">00007f6479ea4000   8192K rw---   [ anon ]</span><br><span class=\"line\">...</span><br><span class=\"line\"> total           447084K</span><br></pre></td></tr></table></figure></p>\n<p>发现同一块用shmget申请的共享内存被映射到进程空间内数次，看来这个就是吃掉内存的元凶。事实上，就是shmat函数被错误地调用了多次，从而被映射了多次。修正代码后，问题解决。</p>\n<hr>\n<p>0x03  问题总结</p>\n<p>总之，感觉出现疑似内存泄漏时，应该首先用pyrasite-shell连上看一下，排除循环引用等垃圾回收的问题，同时注意观察pmap、top等命令的结果。</p>\n","text":"0x00  问题引入<br>虽然Python本身有垃圾回收机制，但是也有内存泄露的可能。这里我对这次调试项目代码的经验作简单总结，予以参考。一般来说，可能出现内存泄露的情况，有如下几种：<br>1.对象被全局变量所引用，而生命周期较长<br>2.gc被禁用，使用gc.disabl","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Dev","slug":"Dev","count":2,"path":"api/tags/Dev.json"}]}]}