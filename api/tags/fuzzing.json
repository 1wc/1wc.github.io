{"name":"fuzzing","slug":"fuzzing","count":1,"postlist":[{"title":"模糊测试与程序分析","slug":"program-analysis-and-fuzzing","date":"2020-04-08T17:05:58.000Z","updated":"2020-04-08T17:18:58.898Z","comments":true,"path":"api/articles/program-analysis-and-fuzzing.json","excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文基于笔者对模糊测试和程序分析的粗浅理解，如有谬误，欢迎斧正。另外，如转载、引用本文，请注明出处，谢谢！</p>\n<h2 id=\"模糊测试概述\"><a href=\"#模糊测试概述\" class=\"headerlink\" title=\"模糊测试概述\"></a>模糊测试概述</h2><p>模糊测试（Fuzzing test）是当前工业界和学术界公认最有效的漏洞挖掘方法。维基百科上的定义如下：模糊测试是一种软件测试技术。其核心思想是将自动或半自动生成的随机数据输入到一个程序中，并监视程序异常，如崩溃，断言（assertion）失败，以发现可能的程序错误，比如内存泄漏等。</p>\n<p>模糊测试有多种分类指标，按照产生针对目标系统的输入的方式不同，可分为基于生成的模糊测试和基于变异的模糊测试。前者适用于目标输入格式已知或逆向可得的场景，需要使用者构建一个模版，模糊测试器基于模版不断生成测试用例；后者则要求使用者提供一个或数个种子文件，然后模糊测试器利用内置的算法逻辑对种子进行变异，从而快速生成大量测试用例。按照对目标程序或计算机系统的所掌握的信息量区分，可分为黑盒模糊测试、白盒模糊测试和灰盒模糊测试。黑盒模糊测试在是目标程序的源代码难以获取，或者可获取但不对源代码进行分析时，只对二进制程序进行测试的一类方法。白盒模糊测试需要借助重量级的程序分析方法，例如符号执行和约束求解，从而降低模糊测试的盲目性并提高覆盖率。灰盒模糊测试介于两者之间，一般采用在编译时插装的方法对源代码进行轻量级的分析，同时保持运行时的性能以期发现更多的安全漏洞。</p>\n<h2 id=\"典型模糊测试工具\"><a href=\"#典型模糊测试工具\" class=\"headerlink\" title=\"典型模糊测试工具\"></a>典型模糊测试工具</h2><p>Michal Zalewski于2014年发布了开源项目AFL，公认为模糊测试领域的一大里程碑。AFL是一款基于变异的灰盒模糊测试器，在用GCC/LLVM对目标程序源代码编译时进行插装，使插装后的程序在动态运行时将路径覆盖信息加载到共享内存，最终模糊测试器可以获取每个变异后种子的边覆盖信息。AFL以边覆盖为反馈信息，基于遗传算法维护一个种子队列，只将标记为有趣的种子放入种子队列。通过上述策略，AFL能够在保持高运行速率的前提下充分提高覆盖率，提高漏洞挖掘的效率与几率。另外，AFL还有基于QEMU的二进制插装解决方案，能够对闭源软件进行覆盖引导的模糊测试 。目前为止，AFL已经发现了开源软件和部分闭源软件中的成千上百个漏洞，包括广泛使用的开源库ffmpeg、curl等和应用程序IE、Firefox等。</p>\n<p>Google后来推出了集成在LLVM框架中的覆盖反馈模糊测试组件LibFuzzer，它与AFL的主体算法相似，但是模糊测试的目标不是待测程序，而是可局部执行的代码片段，这提高了模糊测试的可扩展性，也避免运行非攻击面的代码所造成的额外开销。Google基于LibFuzzer构建了OSS-Fuzz模糊测试系统，对托管在该系统上的开源软件进行持续性的模糊测试，在五个月内从47个开源项目中发现了1000多个bug。</p>\n<h2 id=\"AFL的改进面\"><a href=\"#AFL的改进面\" class=\"headerlink\" title=\"AFL的改进面\"></a>AFL的改进面</h2><p>以AFL、honggfuzz、LibFuzzer为代表的基于变异的灰盒模糊测试器由于其实用性被安全研究人员广泛应用于漏洞挖掘的真实场景中，而在各大安全与软工顶会中也涌现出一批以AFL为基线的工作。这些工作大都对AFL已有的算法与机制进行改进，以适配不同的应用场景。一般来说，模糊测试的目的是为了发现更多的缺陷与安全漏洞，而通常人们用提高覆盖率来近似拟合增加漏洞发现几率。原始的AFL代码整理出一套可行的解决方案，但在其运转的各个环节仍有许多改进面可以提高代码覆盖率。具体来说，主要有如下两点：</p>\n<h3 id=\"1-种子排序、种子打分等种子队列循环调度机制\"><a href=\"#1-种子排序、种子打分等种子队列循环调度机制\" class=\"headerlink\" title=\"1. 种子排序、种子打分等种子队列循环调度机制\"></a>1. 种子排序、种子打分等种子队列循环调度机制</h3><p>AFLfast（CCS’16）中证明了覆盖反馈的灰盒模糊测试可以建模为<strong>马尔可夫链</strong>。<strong>设状态i是程序中的某条分支路径，从状态i到状态j的转移概率pij由模糊测试由执行路径i的种子变异产生执行路径j的种子的概率给出</strong>。该工作通过调整种子打分（得分越高，变异次数越多）机制，在原始得分上增加能量调度，将模糊测试过程引向低频路径，从而在短时间内获得高覆盖率。</p>\n<p>另外，由于AFL内部维护一个种子队列，而该队列中的元素按照优先级排序。如果能够合理调整种子的优先级，使得应当具有高优先级的种子被优先处理，那么也能显著的提高模糊测试效率。</p>\n<h3 id=\"2-变异位置，变异策略等种子变异机制\"><a href=\"#2-变异位置，变异策略等种子变异机制\" class=\"headerlink\" title=\"2. 变异位置，变异策略等种子变异机制\"></a>2. 变异位置，变异策略等种子变异机制</h3><p>原始的AFL具有丰富的变异策略，又保持了很强的随机性，这在漏洞挖掘实践中被证明是有效的。但是，对于路径较深、触发较难的漏洞，这种随机变异为主的方法可能看起来是在赌博。如果我们能针对目标问题增加一些启发式算法，甚至用白盒方法获取一些知识指导变异，从而控制变异的位置和变异的策略，那么自然能提高代码覆盖率，增加模糊测试器的漏洞挖掘能力。</p>","keywords":null,"cover":null,"content":null,"text":"前言本文基于笔者对模糊测试和程序分析的粗浅理解，如有谬误，欢迎斧正。另外，如转载、引用本文，请注明出处，谢谢！模糊测试概述模糊测试（Fuzzing test）是当前工业界和学术界公认最有效的漏洞挖掘方法。维基百科上的定义如下：模糊测试是一种软件测试技术。其核心思想是将自动或半自动","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"fuzzing","slug":"fuzzing","count":1,"path":"api/tags/fuzzing.json"}]}]}