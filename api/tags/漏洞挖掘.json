{"name":"漏洞挖掘","slug":"漏洞挖掘","count":1,"postlist":[{"title":"Google Project博客翻译——关于Adobe符号的二三事","slug":"Google-Project博客翻译——关于Adobe符号的二三事","date":"2020-03-04T08:22:59.000Z","updated":"2020-04-08T17:17:27.807Z","comments":true,"path":"api/articles/Google-Project博客翻译——关于Adobe符号的二三事.json","excerpt":"<h1 id=\"关于Adode-Reader符号的二三事\"><a href=\"#关于Adode-Reader符号的二三事\" class=\"headerlink\" title=\"关于Adode Reader符号的二三事\"></a>关于Adode Reader符号的二三事</h1><p>原文链接：<a href=\"https://googleprojectzero.blogspot.com/2019/10/the-story-of-adobe-reader-symbols.html\" target=\"_blank\" rel=\"noopener\">https://googleprojectzero.blogspot.com/2019/10/the-story-of-adobe-reader-symbols.html</a></p>\n<p>原文作者：Mateusz Jurczyk, Project Zero（j00ru）</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>当前针对客户端应用的安全分析通常由于难以获取源码和调试符号（debug symbols）等其他帮助信息而受到妨碍。因此，一般需要对目标软件进行纯黑盒的逆向工程，以便更好地理解它们的内部逻辑并恢复缺失的上下文信息，这对于识别安全缺陷、对崩溃（crash）进行归类和去重等是必要的。这一阶段可能会令人望而生畏，而花费在手工劳动上的时间相应地减少了测试程序的安全性的时间。换句话说，这可以被认为是在浪费时间。:-)</p>\n<p>另一方面，尽可能有效地利用所有可用资源来辅助研究是安全研究者自己的责任。对于发行历史悠久的成熟软件来说，例如可追溯到90年代的，可获取的资源应当包括旧版本的程序和/或当前支持平台之外的其他编译版本。尽管这些版本现在对于普通用户来说基本没用，它们却可能包含对漏洞猎人而言十分宝贵的元件。在很多情况下，多年来的应用程序内核代码都不会改变，或者仅有轻微变动。所以无论我们能找到什么辅助信息，至少在某种程度上，它们通常都适用于最新版本。基于上述原因，我建议所有的安全研究者在研究工作伊始开展额外的“调研”步骤，因为这将可能极大地节省后续的时间和精力。</p>\n<p>在本篇文章中，我将重点介绍在旧版本和少见版本的Adobe Reader中找到的元数据（metadata）。</p>","keywords":null,"cover":"/image/image-20200224163559287.png","content":null,"text":"关于Adode Reader符号的二三事原文链接：https://googleprojectzero.blogspot.com/2019/10/the-story-of-adobe-reader-symbols.html原文作者：Mateusz Jurczyk, Project ","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"漏洞挖掘","slug":"漏洞挖掘","count":1,"path":"api/tags/漏洞挖掘.json"}]}]}